module Token.Indexing;

import Stdlib.Prelude open;
import Data.Set as Set open using {Set; insert; delete};
import Data.Map as Map open using {Map};
import Anoma open;
import AnomaHelpers open;

ledgerKey (kind : Kind) (account : PublicKey) : KeyValue.Key :=
  KeyValue.mkKey (map natToString [Kind.unKind kind; PublicKey.unPublicKey account]);

ledgerEntries (kind : Kind) (account : PublicKey) : Set Commitment :=
  anomaGet (ledgerKey kind account);

getKinds (rs : List Resource) : Set Kind :=
  for (acc := Set.empty) (r in rs) {insert (anomaKind r) acc};

getAccounts (rs : List Resource) : Set PublicKey :=
  for (acc := Set.empty) (r in rs) {insert (Resource.npk r) acc};

LedgerMapping : Type := Map Kind (Map PublicKey (Set Commitment));

getLedger (rs : List Resource) : LedgerMapping :=
  let
    kinds : List Kind := Set.toList (getKinds rs);
    accounts : List PublicKey := Set.toList (getAccounts rs);
  in for (outerMap := Map.empty) (kind in kinds)
       {Map.insert
         kind
         (for (innerMap := Map.empty) (account in accounts)
           {Map.insert
             account
             ledgerEntries@{
               kind;
               account
             }
             innerMap})
         outerMap};

addCommitments (kind : Kind) (account : PublicKey) (cms : List Commitment) : Set Commitment :=
  for (entries := ledgerEntries kind account) (cm in cms) {Set.insert cm entries};

removeCommitments (kind : Kind) (account : PublicKey) (cms : List Commitment) : Set Commitment :=
  for (entries := ledgerEntries kind account) (cm in cms) {Set.delete cm entries};

instance
Key-Eq : Eq KeyValue.Key :=
  mkEq@{
    eq (l1 l2 : KeyValue.Key) : Bool := anomaEncode l1 == anomaEncode l2
  };

LedgerAssignment : Type := KeyValue.Assignment (Set Commitment);

--- TODO delete
combineAssignments (a b : LedgerAssignment) : List LedgerAssignment :=
  let
    keyA := KeyValue.Assignment.key a;
    keyB := KeyValue.Assignment.key b;
  in case keyA == keyB of
       | false := [a; b]
       | true :=
         [ KeyValue.assign@{
           key := keyA;
           value := union (KeyValue.Assignment.value a) (KeyValue.Assignment.value b)
         }
         ];

addToLedger (kind : Kind) (account : PublicKey) (cms : List Commitment) : LedgerAssignment :=
  KeyValue.assign@{
    key := ledgerKey kind account;
    value := for (entries := ledgerEntries kind account) (cm in cms) {Set.insert cm entries}
  };

removeFromLedger (kind : Kind) (account : PublicKey) (cms : List Commitment) : LedgerAssignment :=
  KeyValue.assign@{
    key := ledgerKey kind account;
    value := for (entries := ledgerEntries kind account) (cm in cms) {delete cm entries}
  };

combineAssignments2 (a b : LedgerAssignment) : LedgerAssignment :=
  KeyValue.assign@{
    key := KeyValue.Assignment.key a;
    value := union (KeyValue.Assignment.value a) (KeyValue.Assignment.value b)
  };
