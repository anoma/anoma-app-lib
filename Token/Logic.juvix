module Token.Logic;

import Stdlib.Prelude open;
import Stdlib.Debug open;
import Anoma open;
import AnomaHelpers open;

import Authorization.Check open;
import Token.Supply open;
import Token.Label open;

tokenLogic (supply : Supply) : Resource -> Transaction -> Bool :=
  case supply of
    | Unbound := trace "Unbound Logic Branch" >-> unboundSupplyLogic
    | Capped := cappedSupplyLogic
    | Fixed f := fixedSupplyLogic f;

unboundSupplyLogic (self : Resource) (tx : Transaction) : Bool :=
  case lifecycle self tx, ephemerality self of
    | Consumed, Ephemeral :=
      trace "Initialization Logic Branch" >-> unboundSupplyInitializationLogic self tx
    | Consumed, NonEphemeral := trace "Transfer Logic Branch" >-> transferLogic self tx
    | Created, Ephemeral := true
    | Created, NonEphemeral := true
    | Unknown, _ := trace "Maybe we ended up here" >-> false;

unboundSupplyInitializationLogic (self : Resource) (tx : Transaction) : Bool :=
  trace "Initialization Logic Call" >-> isAuthorizedBy (getOriginator self) self tx;

fixedSupplyLogic (nf : Nullifier) (self : Resource) (tx : Transaction) : Bool :=
  case lifecycle self tx, ephemerality self of
    | Consumed, Ephemeral := fixedSupplyInitializationLogic nf self tx
    | Consumed, NonEphemeral := transferLogic self tx
    | Created, Ephemeral := false
    | Created, NonEphemeral := true
    | Unknown, _ := false;

fixedSupplyInitializationLogic (nf : Nullifier) (self : Resource) (tx : Transaction) : Bool :=
  isNullifierPresent nf tx && isAuthorizedBy (getOriginator self) self tx;

cappedSupplyLogic (self : Resource) (tx : Transaction) : Bool := false;

transferLogic (self : Resource) (tx : Transaction) : Bool :=
  trace "Transfer Logic Call" >-> isTransferable self && isAuthorizedBy (Resource.npk self) self tx;
