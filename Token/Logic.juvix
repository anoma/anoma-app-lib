module Token.Logic;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open using {failwith};
import Anoma.Resource open;
import Anoma.Identity open;
import Anoma.Proving.Types open;

import AnomaHelpers open;

import Resource.Traits open;
import Authorization.Check open;
import Authorization.Identities open;
import Token.Label open;

tokenLogic
  (supply : Supply)
  (originator : ExternalIdentity)
  (publicInputs : Logic.Instance)
  (privateInputs : Logic.Witness)
  : Bool :=
  case supply of
    | Unbound := unboundSupplyLogic originator publicInputs privateInputs
    | Capped := cappedSupplyLogic originator publicInputs privateInputs
    | Fixed nf := fixedSupplyLogic nf originator publicInputs privateInputs;

unboundSupplyLogic
  (originator : ExternalIdentity)
  (publicInputs : Logic.Instance)
  (privateInputs : Logic.Witness)
  : Bool :=
  let
    tag := Logic.Instance.tag publicInputs;
  in case tag of
       | Logic.Consumed nullifier :=
         let
           -- TODO HOW TO FIX THIS?
           nullifierKey :=
             Universal.internalIdentity |> InternalIdentity.unInternalIdentity |> mkNullifierKey;
           resources := Logic.Witness.created privateInputs;
           maybeSelf :=
             findConsumedResource@{
               nullifier;
               nullifierKey;
               resources
             };
         in case maybeSelf of {
              | nothing := false
              | just self :=
                case HasEphemerality.get self of {
                  | Ephemeral := unboundSupplyInitializationLogic originator self publicInputs
                  | NonEphemeral := transferLogic self publicInputs
                }
            }
       | Logic.Created commitment := true;

unboundSupplyInitializationLogic
  (originator : ExternalIdentity) (self : Resource) (publicInputs : Logic.Instance) : Bool :=
  isAuthorizedBy@{
    signer := originator;
    resource := self;
    publicInputs
  };

fixedSupplyLogic
  (nf : Nullifier)
  (originator : ExternalIdentity)
  (publicInputs : Logic.Instance)
  (privateInputs : Logic.Witness)
  : Bool :=
  let
    tag := Logic.Instance.tag publicInputs;
  in case tag of
       | Logic.Consumed nullifier :=
         let
           -- TODO FIX BY PATTERN MATCHING
           nullifierKey :=
             Universal.internalIdentity |> InternalIdentity.unInternalIdentity |> mkNullifierKey;
           resources := Logic.Witness.created privateInputs;
           maybeSelf :=
             findConsumedResource@{
               nullifier;
               nullifierKey;
               resources
             };
         in case maybeSelf of {
              | nothing := false
              | just self :=
                case HasEphemerality.get self of {
                  | Ephemeral :=
                    fixedSupplyInitializationLogic originator nullifier self publicInputs
                  | NonEphemeral := transferLogic self publicInputs
                }
            }
       | Logic.Created commitment :=
         let
           resources := Logic.Witness.created privateInputs;
           maybeSelf :=
             findCreatedResource@{
               commitment;
               resources
             };
         in case maybeSelf of
              | nothing := false
              | just self :=
                case HasEphemerality.get self of
                  | Ephemeral := false
                  | NonEphemeral := true;

fixedSupplyInitializationLogic
  (originator : ExternalIdentity)
  (nullifier : Nullifier)
  (self : Resource)
  (publicInputs : Logic.Instance)
  : Bool :=
  isNullifierPresent@{
      nullifier;
      nullifierSet := Logic.Instance.nullifiers publicInputs
    }
    && isAuthorizedBy@{
      signer := originator;
      resource := self;
      publicInputs
    };

cappedSupplyLogic
  (originator : ExternalIdentity)
  (publicInputs : Logic.Instance)
  (privateInputs : Logic.Witness)
  : Bool := failwith "NOT IMPLEMENTED";

transferLogic (self : Resource) (publicInputs : Logic.Instance) : Bool :=
  let
    signer :=
      -- TODO Use ownership standard here.
        self
        |> Resource.nullifierKeyCommitment
        |> NullifierKeyCommitment.unNullifierKeyCommitment
        |> mkExternalIdentity;
  in isTransferable self
    && isAuthorizedBy@{
      signer;
      resource := self;
      publicInputs
    };
