module Token.Transaction;

import Stdlib.Prelude open;
import Stdlib.Data.Nat.Ord open using {compare};
import Data.Map open;
import Anoma open;
import AnomaHelpers open;

import Authorization.Identities open;
import Authorization.Check open;
import Authorization.Message open;
import Utils.Dummy.Transaction as Dummy open using {finalize};
import Token.Resource open;
import Token.Label open;
import Token.Supply open;
import Token.Logic open;
import Token.Error open;

--- Initializes a token ;Resource; owned by an receiver ;PublicKey;.
--- This requires an ephemeral resource to be consumed.
--- The function returns a ;TokenError; if the calling ;KeyPair; is not the owner.
initialize (self : KeyPair) (label : Label) (quantity : Nat) (receiver : PublicKey)
: Result TokenError Transaction :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    mySecret : PrivateKey := KeyPair.privKey self;

    newToken : Resource := mkToken@{quantity; tokenLabel := label; npk := receiver};
    ephToken := newToken@Resource{npk := myself; eph := true};

    consumedRs : List Resource := [ephToken];
    createdRs : List Resource := [newToken];
    extraData : Map Bytes32 Bytes := mkResourceRelationshipExtraData@{
      nullifierKey := mySecret; 
      origins := consumedRs;
      mustBeConsumed := [];
      mustBeCreated := createdRs
    };
    tx : Transaction := mkTransaction mySecret consumedRs createdRs extraData;
   in
     case Label.supply label of
       | Unbound := ok tx
       | Capped := throw mkError@{msg := "Tokens with capped supply are not supported yet."}
       | (Fixed f) := ok
          compose@{
            tx1 := tx;
            tx2 := Dummy.finalize@{self; dummy := anomaGet(FixingNullifier.nf f)}
          };

--- Finalizes a token ;Resource;, if the calling ;KeyPair; is the owner.
--- This requires an ephemeral resource to be created.
--- The function returns a ;TokenError; if the calling ;KeyPair; is not the owner.
finalize (self : KeyPair) (token : Resource)
: Result TokenError Transaction :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    mySecret : PrivateKey := KeyPair.privKey self;
    owner : PublicKey := Resource.npk token;

    ephToken := token@Resource{eph := true; npk := Zero.pubKey};

    consumedRs : List Resource := [token];
    createdRs : List Resource := [ephToken];
    extraData : Map Bytes32 Bytes := mkResourceRelationshipExtraData@{
      nullifierKey := mySecret; 
      origins := consumedRs;
      mustBeConsumed := [];
      mustBeCreated := createdRs
    };
  in if
    | owner /= myself := throw mkUnauthorizedError@{expected := myself; actual := owner}
    | else :=
        case getSupply token of
          | Unbound := ok (mkTransaction mySecret consumedRs createdRs extraData)
          | Capped := throw mkError@{msg := "Tokens with capped supply are not supported yet."}
          | (Fixed _) := throw mkError@{msg := "Tokens with fixed supply cannot be burned."};

--- Transfers the token ;Resource; to a receiver, if the calling ;KeyPair; is the owner.
--- The function returns a ;TokenError; if the calling ;KeyPair; is not the owner.
transfer (self : KeyPair) (token : Resource) (receiver : PublicKey)
: Result TokenError Transaction  :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    mySecret : PrivateKey := KeyPair.privKey self;
    owner : PublicKey := Resource.npk token;

    newToken := token@Resource{npk := receiver};

    consumedRs : List Resource := [token];
    createdRs : List Resource := [newToken];
    extraData : Map Bytes32 Bytes := mkResourceRelationshipExtraData@{
      nullifierKey := mySecret; 
      origins := consumedRs;
      mustBeConsumed := [];
      mustBeCreated := createdRs
    };
  in if
    | not (isTransferable token) := throw mkNonTransferableError
    | owner /= myself := throw mkUnauthorizedError@{expected := myself; actual := owner}
    | else := ok (mkTransaction mySecret consumedRs createdRs extraData);


--- Splits a token ;Resource;, if the calling ;KeyPair; is the owner.
--- The function returns a ;TokenError; if
--- - the calling ;KeyPair; is not the owner or
--- - the quantities do not balance,
split (self : KeyPair) (token : Resource) (quantitiesAndReceivers : List (Pair Nat PublicKey))
: Result TokenError Transaction :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    mySecret : PrivateKey := KeyPair.privKey self;
    owner : PublicKey := Resource.npk token;

    label : Label := anomaDecode (Resource.label token);
    sum : Nat := for (acc := 0) ((quantity, _) in quantitiesAndReceivers) {quantity + acc};
    balance := Resource.quantity token;

    consumedRs : List Resource := [token];
    createdRs : List Resource := map ((quantity, receiver) in quantitiesAndReceivers) {
        mkToken@{quantity; tokenLabel := label; npk := receiver}
      };
    extraData : Map Bytes32 Bytes := mkResourceRelationshipExtraData@{
      nullifierKey := mySecret; 
      origins := consumedRs;
      mustBeConsumed := [];
      mustBeCreated := createdRs
    };
  in if
    | not (isTransferable token) := throw mkNonTransferableError
    | owner /= myself := throw mkUnauthorizedError@{expected := myself; actual := owner}
    | balance /= sum := throw mkInsufficientQuantityError@{limit := balance; actual := sum}
    | else := ok (mkTransaction mySecret consumedRs createdRs extraData);


--- Sends an quantity of token ;Resource; to a receiver, if the calling ;KeyPair; is the owner.
--- If the quantity is lower than of the quantity of the consumed ;Resource;, the function creates
--- a second ;Resource; with the difference being owned by the caller.
--- The function returns a ;TokenError; if
--- - the calling ;KeyPair; is not the owner or
--- - the quantity exceeds the quantity of the resource.
send (self : KeyPair) (token : Resource) (quantity : Nat) (receiver : PublicKey)
: Result TokenError Transaction  :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    availableQuantity : Nat := Resource.quantity token;
  in case (compare availableQuantity quantity) of
      | LT := throw mkInsufficientQuantityError@{limit := availableQuantity; actual := quantity}
      | EQ := transfer self token receiver
      | GT :=
        let
          difference : Nat := toNat (intSubNat availableQuantity quantity);
        in
          split self token [(quantity, receiver); (difference, myself)];

--- Merges token ;Resource;s, if the calling ;KeyPair; is the owner of all
--- of them and the ;Label;s match.
--- The function returns a ;TokenError; if
--- - the calling ;KeyPair; is not the owner of the tokens or
--- - one of the token ;Label;s differs or
--- - one of the token ;Resource; logics differs.
merge (self : KeyPair) (tokens : List Resource) (receiver : PublicKey)
: Result TokenError Transaction :=
  case tokens of
    | nil := throw mkInsufficientElementsError@{limit := 1; actual := 0}
    | (t :: _) :=
    let
      myself : PublicKey := KeyPair.pubKey self;
      mySecret : PrivateKey := KeyPair.privKey self;

      kind : Kind := anomaKind t;
      totalQuantity : Nat := for (acc := 0) (t in tokens) {Resource.quantity t + acc};

      merged : Resource := t@Resource{quantity := totalQuantity; npk := receiver};
      consumedRs : List Resource := tokens;
      createdRs : List Resource := [merged];
      extraData : Map Bytes32 Bytes := mkResourceRelationshipExtraData@{
        nullifierKey := mySecret; 
        origins := consumedRs;
        mustBeConsumed := [];
        mustBeCreated := createdRs
      };
      in if 
        | not (isTransferable t) := throw mkNonTransferableError
        | else :=
          case find ((/=) myself) (map Resource.npk tokens) of
            | just notMyself := throw mkUnauthorizedError@{expected := myself; actual := notMyself}
            | nothing :=
              case find ((/=) kind) (map anomaKind tokens) of
                | just otherKind := throw mkInvalidKindError@{expected := kind; actual := otherKind}
                | nothing := ok (mkTransaction mySecret consumedRs createdRs extraData);
