module Token.Transaction;

import Stdlib.Prelude open;
import Data.Map open;
import Anoma open;
import AnomaHelpers open;

import Token.Resource open;
import Token.Label open;
import Token.Logic open;
import Authorization.Owner open;

--- Mints a token ;Resource; owned by an receiver ;PublicKey;.
--- This requires an ephemeral resource to be consumed.
mint
  (self : KeyPair)
  (label : Label)
  (amount : Nat)
  (receiver : PublicKey)
  : Transaction :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    mySecret : PrivateKey := KeyPair.privKey self;

    ephToken : Resource :=
      mkToken
        true
        amount
        label
        mkOwner@{
          owner := myself
        };
    newToken : Resource :=
      mkToken
        false
        amount
        label
        mkOwner@{
          owner := receiver
        };

    consumedRs : List Resource := [ephToken];
    createdRs : List Resource := [newToken];
    extraData : Map Bytes32 Bytes :=
      mkAuthExtraData mySecret consumedRs createdRs;
  in mkTransaction mySecret consumedRs createdRs extraData;

--- Burns a token ;Resource;, if the calling ;KeyPair; is the owner.
--- This requires an ephemeral resource to be created.
--- If the calling ;KeyPair; is not the owner, this function returns nothing.
burn
  (self : KeyPair) (token : Resource) : Maybe Transaction :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    mySecret : PrivateKey := KeyPair.privKey self;

    -- This ephemeral resource is needed for the total balance check.
    ephToken :=
      mkToken
        true
        (Resource.quantity token)
        (getLabel token)
        mkOwner@{
          owner := 0
        };

    consumedRs : List Resource := [token];
    createdRs : List Resource := [ephToken];
    extraData : Map Bytes32 Bytes :=
      mkAuthExtraData mySecret consumedRs createdRs;
  in if
    | getOwner (token) /= myself := nothing
    | else :=
      just
        (mkTransaction mySecret consumedRs createdRs extraData);

--- Sends an amount of token ;Resource; to receiver, if the calling ;KeyPair; is the owner.
--- If the calling ;KeyPair; is not the owner, this function returns nothing.
--- If the amount exceeds the quantity available in the resource, the function returns nothing.
send
  (self : KeyPair)
  (token : Resource)
  (amount : Nat)
  (receiver : PublicKey)
  : Maybe Transaction :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    availableAmount : Nat := Resource.quantity token;
  in if
    | getOwner (token) /= myself := nothing
    | availableAmount < amount := nothing
    | availableAmount == amount := transfer self token receiver
    | availableAmount > amount :=
      let
        remainder : Nat :=
          toNat (intSubNat availableAmount amount);
      in split self token ((amount, receiver) :: (remainder, myself) :: nil)
    | else := nothing;

--- Transfers the token ;Resource; to a receiver, if the calling ;KeyPair; is the owner.
--- If the calling ;KeyPair; is not the owner, this function returns nothing.
transfer
  (self : KeyPair)
  (token : Resource)
  (receiver : PublicKey)
  : Maybe Transaction :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    mySecret : PrivateKey := KeyPair.privKey self;

    newToken :=
      mkToken
        false
        (Resource.quantity token)
        (getLabel token)
        mkOwner@{
          owner := receiver
        };

    consumedRs : List Resource := [token];
    createdRs : List Resource := [newToken];
    extraData : Map Bytes32 Bytes :=
      mkAuthExtraData mySecret consumedRs createdRs;
  in if
    | getOwner token == myself :=
      just
        (mkTransaction mySecret consumedRs createdRs extraData)
    | else := nothing;

--- Splits a token ;Resource;, if the calling ;KeyPair; is the owner.
--- If the calling ;KeyPair; is not the owner or if the amounts do not balance, this function returns nothing.
split
  (self : KeyPair)
  (token : Resource)
  (amountsAndReceivers : List (Pair Nat PublicKey))
  : Maybe Transaction :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    mySecret : PrivateKey := KeyPair.privKey self;

    label : Label := anomaDecode (Resource.label token);
    sum : Nat := for (acc := 0) ((amount, _) in amountsAndReceivers) {amount + acc};

    consumedRs : List Resource := [token];
    createdRs : List Resource := map ((amount, receiver) in amountsAndReceivers) {mkToken false amount label mkOwner@{owner := receiver;}};
    extraData : Map Bytes32 Bytes := mkAuthExtraData mySecret consumedRs createdRs;
  in if
    | getOwner token == myself
      && Resource.quantity token == sum :=
      just
        (mkTransaction mySecret consumedRs createdRs extraData)
    | else := nothing;

--- Merges two token ;Resource;s, if the calling ;KeyPair; is the owner of both.
--- If the calling ;KeyPair; is not the owner, this function returns nothing.
merge
  (self : KeyPair)
  (tokens : List Resource)
  (receiver : PublicKey)
  : Maybe Transaction :=
  case tokens of
    | nil := nothing
    | (t :: ts) :=
    let
      myself : PublicKey := KeyPair.pubKey self;
      mySecret : PrivateKey := KeyPair.privKey self;

      label : Label := getLabel t;
      owner : PublicKey := getOwner t;
      sum : Nat := for (acc := 0) (t in tokens) {Resource.quantity t + acc};

      merged : Resource := mkToken false sum label mkOwner@{owner := myself};
      consumedRs : List Resource := tokens;
      createdRs : List Resource := [merged];
      extraData : Map Bytes32 Bytes := mkAuthExtraData mySecret consumedRs createdRs;
    in if
      | all (ti in ts) (
          getLabel ti == label
          && getOwner ti == myself)
          := just (mkTransaction mySecret consumedRs createdRs extraData)
      | else := nothing;
