module Token.Transaction;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open using {failwith};
import Stdlib.Data.Nat.Ord open using {compare};
import Data.Map open;
import Anoma open;
import AnomaHelpers open;

import Authorization.Owner open;
import Authorization.Message open;
import Token.Resource open;
import Token.Label open;
import Token.Logic open;
import Token.Error open;
import Authorization.Owner open;
import Utils.Dummy.Transaction open;

--- Mints a token ;Resource; owned by an receiver ;PublicKey;.
--- This requires an ephemeral resource to be consumed.
--- The function returns a ;TokenError; if the calling ;KeyPair; is not the owner.
mint (self : KeyPair) (label : Label) (amount : Nat) (receiver : PublicKey) : Either TokenError Transaction :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    mySecret : PrivateKey := KeyPair.privKey self;

    ephToken : Resource := mkToken true amount label mkOwner@{owner := myself};
    newToken : Resource := mkToken false amount label mkOwner@{owner := receiver};

    consumedRs : List Resource := [ephToken];
    createdRs : List Resource := [newToken];
    extraData : Map Bytes32 Bytes :=
      mkLinkedCommitmentSetExtraData mySecret consumedRs createdRs;
    tx : Transaction := mkTransaction mySecret consumedRs createdRs extraData;
   in
     case Label.supply label of
       | Unbound := pass tx
       | Capped := throw mkError@{msg := "Tokens with capped supply are not supported yet."}
       | Fixed := pass
          composeTransactions@{
            tx1 := tx;
            tx2 := consumeDummy@{_self := self; _dummy := anomaGet(Label.uniqueness label)}
          };

--- Burns a token ;Resource;, if the calling ;KeyPair; is the owner.
--- This requires an ephemeral resource to be created.
--- The function returns a ;TokenError; if the calling ;KeyPair; is not the owner.
burn (self : KeyPair) (token : Resource) : Either TokenError Transaction :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    mySecret : PrivateKey := KeyPair.privKey self;
    owner : PublicKey := getOwner token;

    ephToken := mkToken true (Resource.quantity token) (getLabel token) mkOwner@{owner := 0};

    consumedRs : List Resource := [token];
    createdRs : List Resource := [ephToken];
    extraData : Map Bytes32 Bytes :=
      mkLinkedCommitmentSetExtraData mySecret consumedRs createdRs;
  in if
    | owner /= myself := throw mkUnauthorizedError@{expected := myself; actual := owner}
    | else :=
        case getSupply token of
          | Unbound := pass (mkTransaction mySecret consumedRs createdRs extraData)
          | Capped := throw mkError@{msg := "Tokens with capped supply are not supported yet."}
          | Fixed := pass (mkTransaction mySecret consumedRs createdRs extraData);

--- Transfers the token ;Resource; to a receiver, if the calling ;KeyPair; is the owner.
--- The function returns a ;TokenError; if the calling ;KeyPair; is not the owner.
transfer
  (self : KeyPair)
  (token : Resource)
  (receiver : PublicKey)
  : Either TokenError Transaction  :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    mySecret : PrivateKey := KeyPair.privKey self;
    owner : PublicKey := getOwner token;

    newToken := mkToken false (Resource.quantity token) (getLabel token) mkOwner@{owner := receiver};

    consumedRs : List Resource := [token];
    createdRs : List Resource := [newToken];
    extraData : Map Bytes32 Bytes :=
      mkLinkedCommitmentSetExtraData mySecret consumedRs createdRs;
  in if
    | owner /= myself := throw mkUnauthorizedError@{expected := myself; actual := owner}
    | else := pass (mkTransaction mySecret consumedRs createdRs extraData);


--- Splits a token ;Resource;, if the calling ;KeyPair; is the owner.
--- The function returns a ;TokenError; if
--- - the calling ;KeyPair; is not the owner or
--- - the amounts do not balance,
split
  (self : KeyPair)
  (token : Resource)
  (amountsAndReceivers : List (Pair Nat PublicKey))
  : Either TokenError Transaction :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    mySecret : PrivateKey := KeyPair.privKey self;
    owner : PublicKey := getOwner token;

    label : Label := anomaDecode (Resource.label token);
    sum : Nat := for (acc := 0) ((amount, _) in amountsAndReceivers) {amount + acc};
    balance := Resource.quantity token;

    consumedRs : List Resource := [token];
    createdRs : List Resource := map ((amount, receiver) in amountsAndReceivers) {mkToken false amount label mkOwner@{owner := receiver;}};
    extraData : Map Bytes32 Bytes := mkLinkedCommitmentSetExtraData mySecret consumedRs createdRs;
  in if
    | owner /= myself := throw mkUnauthorizedError@{expected := myself; actual := owner}
    | balance /= sum := throw mkInsufficientQuantityError@{limit := balance; actual := sum}
    | else := pass (mkTransaction mySecret consumedRs createdRs extraData);


--- Sends an amount of token ;Resource; to a receiver, if the calling ;KeyPair; is the owner.
--- If the amount is lower than of the quantity of the consumed ;Resource;, the function creates
--- a second ;Resource; with the remainder being owned by the caller.
--- The function returns a ;TokenError; if
--- - the calling ;KeyPair; is not the owner or
--- - the amount exceeds the quantity of the resource.
send
  (self : KeyPair)
  (token : Resource)
  (amount : Nat)
  (receiver : PublicKey)
  : Either TokenError Transaction  :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    availableAmount : Nat := Resource.quantity token;
  in
    case (compare availableAmount amount) of
    | LT := throw mkInsufficientQuantityError@{limit := availableAmount; actual := amount}
    | EQ := transfer self token receiver
    | GT :=
      let
        remainder : Nat := toNat (intSubNat availableAmount amount);
      in
        split self token ((amount, receiver) :: (remainder, myself) :: nil);

--- Merges token ;Resource;s, if the calling ;KeyPair; is the owner of all
--- of them and the ;Label;s match.
--- The function returns a ;TokenError; if
--- - the calling ;KeyPair; is not the owner of the tokens or
--- - one of the token ;Label;s differs or
--- - one of the token ;Resource; logics differs.
merge
  (self : KeyPair)
  (tokens : List Resource)
  (receiver : PublicKey)
  : Either TokenError Transaction :=
  case tokens of
    | nil := throw mkInsufficientElementsError@{limit := 1; actual := 0}
    | (t :: ts) :=
    let
      myself : PublicKey := KeyPair.pubKey self;
      mySecret : PrivateKey := KeyPair.privKey self;

      label : Label := getLabel t;
      logic : Nat := anomaEncode(Resource.logic t);
      owner : PublicKey := getOwner t;
      sum : Nat := for (acc := 0) (t in tokens) {Resource.quantity t + acc};

      merged : Resource := mkToken false sum label mkOwner@{owner := myself};
      consumedRs : List Resource := tokens;
      createdRs : List Resource := [merged];
      extraData : Map Bytes32 Bytes := mkLinkedCommitmentSetExtraData mySecret consumedRs createdRs;
      in case find ((/=) owner) (map getOwner tokens) of
        | just wrongOwner := throw mkUnauthorizedError@{expected := myself; actual := wrongOwner}
        | nothing :=
          case find ((/=) label) (map getLabel tokens) of
          | just wrongLabel := throw mkInvalidLabelError@{expected := label; actual := wrongLabel}
          | nothing :=
            case find ((/=) logic) (map getLogic tokens) of
            | just wrongLogic := throw mkInvalidLogicError@{expected := logic; actual := wrongLogic}
            | nothing := pass (mkTransaction mySecret consumedRs createdRs extraData);
