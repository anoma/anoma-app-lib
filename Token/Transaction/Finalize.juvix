module Token.Transaction.Finalize;

import Stdlib.Prelude open;
import Anoma open;
import AnomaHelpers open;

import Authorization.Identities open;
import Authorization.Check open;
import Authorization.Message open;
import Token.Resource open;
import Token.Label open;
import Token.Supply open;
import Token.Error open;

--- Finalizes a token ;Resource;, if the calling ;KeyPair; is the owner.
--- This requires an ephemeral resource to be created.
--- The function returns a ;TokenError; if the calling ;KeyPair; is not the owner.
finalize (self : KeyPair) (token : Resource)
: Result TokenError Transaction :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    nk : PrivateKey := KeyPair.privKey self;
    owner : PublicKey := Resource.npk token;
    ephToken := token@Resource{eph := true; npk := Zero.pubKey};
  in if
    | owner /= myself := throw mkUnauthorizedError@{expected := myself; actual := owner}
    | else :=
        case getSupply token of
          | Unbound := ok (mkTxWithExtraData nk [token] [ephToken])
          | Capped := throw mkError@{msg := "Tokens with capped supply are not supported yet."}
          | (Fixed _) := throw mkError@{msg := "Tokens with fixed supply cannot be burned."};

