module Token.Transaction.Swap;

import Stdlib.Prelude open;
import Data.Set as Set open using {Set};
import Data.Map as Map open using {empty};
import Anoma open;
import AnomaHelpers open;

import Authorization.Check open;
import Authorization.Message open;
import Intent.Asset open;
import Token.Error open;
import Token.Label open;
import Token.Indexing open;
import Token.Transaction.Swap.Resource open;
import Token.Transaction.Swap.Solution open;

mkSwapTx
  (self : KeyPair)
  (give : List Resource)
  (want : QuantifiedAssets)
  (solver : PublicKey)
  : Transaction :=
  mkTxWithExtraData@{
    nk := KeyPair.privKey self;
    consumed := give;
    created :=
      [ mkSwapIntent@{
        want;
        receiver := KeyPair.pubKey self;
        solver
      }
      ]
  };

--- Swaps a token ;Resource; ;Set; for a list of ;QuantifiedAssets;.
--- The function returns a ;TokenError; if
--- - the token is non-transferable
--- - the calling ;KeyPair; is not the owner of the token.
swap
  (self : KeyPair)
  -- TODO use Set
  (give : List Resource)
  (want : QuantifiedAssets)
  (solver : PublicKey)
  : Result TokenError Transaction :=
  case give of
    | nil :=
      throw
        mkInsufficientElementsError@{
          limit := 1;
          actual := 0
        }
    | _ :: _ :=
      case find ((/=) (true)) (map isTransferable give) of
        | just _ := throw mkNonTransferableError
        | nothing :=
          case find ((/=) (KeyPair.pubKey self)) (map Resource.npk give) of
            | just notMyself :=
              throw
                mkUnauthorizedError@{
                  expected := KeyPair.pubKey self;
                  actual := notMyself
                }
            | nothing :=
              ok
                mkSwapTx@{
                  self;
                  give;
                  want;
                  solver
                };

--- Settles a ;Set; of ;Transaction;s by composing them with
--- ;Transaction;s obtained from a ;Set; of ;Solution;.
--- The function returns a ;TokenError; if
--- - the calling ;KeyPair; is not designated intent solver.
settle
  (self : KeyPair)
  -- TODO use Set
  (txs : List Transaction)
  -- TODO use Set
  (solutions : List Solution)
  : Result TokenError Transaction :=
  let
    myself := KeyPair.pubKey self;
    solutionTxs := map (Solution.toTransaction self) (solutions);
  in case find ((/=) myself) (map \ {s := Resource.npk (Solution.intent s)} solutions) of
       | just notMyself :=
         throw
           mkUnauthorizedError@{
             expected := myself;
             actual := notMyself
           }
       | nothing := ok (composeAll (txs ++ solutionTxs));
