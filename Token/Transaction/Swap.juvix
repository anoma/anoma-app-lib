module Token.Transaction.Swap;

import Stdlib.Prelude open;
import Data.Set as Set open using {Set};
import Data.Map as Map open using {empty};
import Anoma open;
import AnomaHelpers open;

import Authorization.Check open;
import Authorization.Message open;
import Intent.Asset open;
import Token.Error open;
import Token.Label open;
import Token.Indexing open;
import Token.Transaction.Swap.Resource open;
import Token.Transaction.Swap.Solution open;

--- Swaps a token ;Resource; for a list of ;QuantifiedAssets;.
--- The function returns a ;TokenError; if
--- - the token is non-transferable
--- - the calling ;KeyPair; is not the owner of the token.
swap
  (self : KeyPair)
  (give : Set Resource)
  (want : QuantifiedAssets)
  (solver : PublicKey)
  : Result TokenError (TxData (Set Commitment)) :=
  let
    giveList := Set.toList give;
  in case giveList of
       | nil :=
         throw
           mkInsufficientElementsError@{
             limit := 1;
             actual := 0
           }
       | t :: _ :=
         let
           myself : PublicKey := KeyPair.pubKey self;
           nk : PrivateKey := KeyPair.privKey self;
           owner : PublicKey := Resource.npk t;
         in if
           | not (isTransferable t) := throw mkNonTransferableError
           | else :=
             case find ((/=) myself) (map Resource.npk giveList) of
               | just notMyself :=
                 throw
                   mkUnauthorizedError@{
                     expected := myself;
                     actual := notMyself
                   }
               | nothing :=
                 ok
                   mkTxWithExtraData@{
                     nk;
                     consumed := giveList;
                     created :=
                       [ mkSwapIntent@{
                         want;
                         receiver := myself;
                         solver
                       }
                       ]
                   };

settle
  (self : KeyPair)
  (solutions : Set Solution)
  (txDatas : List (TxData (Set Commitment)))
  : Result TokenError (TxData (Set Commitment)) :=
  let
    appliedSolutions : List (TxData (Set Commitment)) :=
      map (Solution.toTxData self) (Set.toList solutions);
  in ok (composeAllTxData (appliedSolutions ++ txDatas));
