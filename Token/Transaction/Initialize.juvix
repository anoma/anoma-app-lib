module Token.Transaction.Initialize;

import Stdlib.Prelude open;
import Data.Map open;
import Anoma open;
import AnomaHelpers open;

import Authorization.Message open;
import Utils.Dummy.Transaction.Finalize as Dummy open;
import Token.Resource open;
import Token.Label open;
import Token.Supply open;
import Token.Error open;

--- Initializes a token ;Resource; owned by an receiver ;PublicKey;.
--- This requires an ephemeral resource to be consumed.
--- The function returns a ;TokenError; if the calling ;KeyPair; is not the owner.
initialize (self : KeyPair) (label : Label) (quantity : Nat) (receiver : PublicKey)
: Result TokenError Transaction :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    nk : PrivateKey := KeyPair.privKey self;
    newToken : Resource := mkToken@{quantity; tokenLabel := label; npk := receiver};
    ephToken := newToken@Resource{npk := myself; eph := true};
    tx : Transaction := mkTxWithExtraData nk [ephToken] [newToken];
   in
     case Label.supply label of
       | Unbound := ok tx
       | Capped := throw mkError@{msg := "Tokens with capped supply are not supported yet."}
       | (Fixed f) := ok
          compose@{
            tx1 := tx;
            tx2 := Dummy.finalize@{self; dummy := anomaGet(FixingNullifier.nf f)}
          };

