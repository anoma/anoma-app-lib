module Token.Transaction.Initialize;

import Stdlib.Prelude open;
import Data.Set as Set open using {Set};
import Anoma open;
import AnomaHelpers open;

import Authorization.Message open;
import Utils.Dummy.Transaction as Dummy open;
import Token.Resource open;
import Token.Label open;
import Token.Supply open;
import Token.Error open;
import Token.Indexing open;

--- Initializes a token ;Resource; owned by an receiver ;PublicKey;.
--- This requires an ephemeral resource to be consumed.
--- The function returns a ;TokenError; if the calling ;KeyPair; is not the owner.
initialize (self : KeyPair) (label : Label) (quantity : Nat) (receiver : PublicKey)
: Result TokenError (TxData (Set Commitment)) :=
  let
    myself : PublicKey := KeyPair.pubKey self;
    nk : PrivateKey := KeyPair.privKey self;
    newToken : Resource := mkToken@{quantity; tokenLabel := label; npk := receiver};
    ephToken := newToken@Resource{npk := myself; eph := true};
    returnVal := mkTxWithExtraData@{nk; consumed := [ephToken]; created := [newToken]};
  in
    case Label.supply label of
      | Unbound := ok returnVal
      | Capped := throw mkError@{msg := "Tokens with capped supply are not supported yet."}
      | (Fixed f) := ok
        mkTxData@{
          tx := compose@{
            tx1 := TxData.tx returnVal;
            tx2 := Dummy.finalize@{self; dummy := anomaGet(FixingNullifier.nf f)}
          }; 
          assignment := TxData.assignment returnVal
        };

