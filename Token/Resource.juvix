module Token.Resource;

import Stdlib.Prelude open;
import Anoma.Resource open;
import Anoma.Identity.External open;

import AnomaHelpers open;

import Resource.Traits open;
import Token.Label open;
import Token.Logic open;
import Anoma.Builtin.System open;
import Anoma.Utils open;

module Token;
  type Token := mk {resource : Resource};

  create
    (quantity : Quantity)
    (tokenLabel : TokenLabel)
    (nullifierKeyCommitment : NullifierKeyCommitment)
    {ephemeral : Bool := false}
    : Token :=
    mk
      mkResource@{
        logicRef :=
          Ref.toRef (tokenLogic (TokenLabel.supply tokenLabel) (TokenLabel.originator tokenLabel));
        labelRef := toLabelRef tokenLabel;
        valueRef := Ref.toRef (mkValue 0);
        quantity;
        ephemeral;
        nullifierKeyCommitment;
        nonce := mkNonce rand;
        randSeed := mkRandSeed rand
      };

  open Token public;
end;

open Token using {Token} public;

instance
Token-Convertable : Convertable Token :=
  mkConvertable@{
    toResource (token : Token) : Resource := Token.resource token;
    fromResource (resource : Resource) : Token :=
      Token.mk@{
        resource
      }
  };

-- TODO Refactor
kindFromTokenLabel (tokenLabel : TokenLabel) : Kind :=
  KindInternal.kind@{
    logicRef :=
      Ref.toRef (tokenLogic (TokenLabel.supply tokenLabel) (TokenLabel.originator tokenLabel));
    labelRef := toLabelRef tokenLabel
  };

instance
Token-HasQuantity : HasQuantity Token := FromConvertable.hasQuantity {Token};


instance
Token-HasOwner : HasOwner Token := FromConvertable.hasOwner {Token};

instance
Token-HasEphemerality : HasEphemerality Token := FromConvertable.hasEphemerality {Token};

instance
Token-HasLogic : HasLogic Token := FromConvertable.hasLogic {Token};

instance
Token-HasKind : HasKind Token := FromConvertable.hasKind {Token};

instance
Token-Label-HasLabel : HasLabel Token TokenLabel :=
  mkHasLabel@{
    get (token : Token) : TokenLabel :=
      token |> Convertable.toResource |> Resource.labelRef |> fromLabelRef;
    set (tokenLabel : TokenLabel) (token : Token) : Token :=
      (token |> Convertable.toResource)@Resource{labelRef := toLabelRef tokenLabel}
        |> Convertable.fromResource
  };

instance
Token-HasSupply : HasSupply Token :=
  mkHasSupply@{
    get (token : Token) : Supply := token |> HasLabel.get |> TokenLabel.supply;
    set (supply : Supply) (token : Token) : Token :=
      let
        newLabel := (HasLabel.get token)@TokenLabel{supply := supply};
      in HasLabel.set newLabel token
  };

instance
Token-HasTransferability : HasTransferability Token :=
  mkHasTransferability@{
    get (token : Token) : Transferability := token |> HasLabel.get |> TokenLabel.transferability;
    set (transferability : Transferability) (token : Token) : Token :=
      let
        newLabel := (HasLabel.get token)@TokenLabel{transferability := transferability};
      in HasLabel.set newLabel token
  };

instance
Token-HasOriginator : HasOriginator Token :=
  mkHasOriginator@{
    get (token : Token) : ExternalIdentity := token |> HasLabel.get |> TokenLabel.originator;
    set (originator : ExternalIdentity) (token : Token) : Token :=
      let
        newLabel := (HasLabel.get token)@TokenLabel{originator := originator};
      in HasLabel.set newLabel token
  };
