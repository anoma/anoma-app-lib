module Tests.Swap;

import Test.JuvixUnit open;

import Stdlib.Prelude open;
import Data.Set as Set open using {Set};
import Anoma open;
import Anoma.Rep open;
import AnomaHelpers open;

import Authorization.Identities open;
import Authorization.Message open;
import Token.Label open;
import Token.Logic open;
import Token.Error open;
import Token.Resource open;
import Token.Supply open;
import Token.Transaction.Swap open;

import Intent.Asset open;
import Token.Transaction.Swap.Resource open;
import Token.Transaction.Swap.Solution open;

import Utils.Dummy.Resource open;

import Tests.Helpers open;

wantAlice : QuantifiedAssets := mkQuantifiedAssets All [mkAsset 5 bobKudos];

wantBob : QuantifiedAssets := mkQuantifiedAssets All [mkAsset 3 aliceKudos];

aliceTokenOwnedByAlice : Resource := mkToken 3 aliceKudosLabel (Alice.pubKey);

bobTokenOwnedByBob : Resource := mkToken 5 bobKudosLabel (Bob.pubKey);

aliceIntentTx : Transaction :=
  mkSwapTx@{
    self := Alice.keyPair;
    give := [aliceTokenOwnedByAlice];
    want := wantAlice;
    solver := Carol.pubKey
  };

aliceSwapIntentResource : Resource :=
  mkSwapIntent@{
    want := wantAlice;
    receiver := Alice.pubKey;
    solver := Carol.pubKey
  };

bobIntentTx : Transaction :=
  mkSwapTx@{
    self := Bob.keyPair;
    give := [bobTokenOwnedByBob];
    want := wantBob;
    solver := Carol.pubKey
  };

bobSwapIntentResource : Resource :=
  mkSwapIntent@{
    want := wantBob;
    receiver := Bob.pubKey;
    solver := Carol.pubKey
  };

balancedTx : Transaction :=
  let
    solutionForAlice : Solution :=
      Solution.mk@{
        intent := aliceSwapIntentResource;
        created := Set.fromList [bobTokenOwnedByBob@Resource{nonce := 998}]
      };
    solutionForBob : Solution :=
      Solution.mk@{
        intent := bobSwapIntentResource;
        created := Set.fromList [aliceTokenOwnedByAlice@Resource{nonce := 999}]
      };
    solutionTxs := map (Solution.toTransaction Carol.keyPair) [solutionForAlice; solutionForBob];
  in composeAll ([aliceIntentTx; bobIntentTx] ++ solutionTxs);

tests : List Test :=
  [ testCase
    "Alice's token should be satisfied"
    (expectTrue (tokenLogic Unbound aliceTokenOwnedByAlice balancedTx))
  ; testCase
    "Alice's intent resoure logic should be satisfied"
    (expectTrue (tokenLogic Unbound aliceSwapIntentResource balancedTx))
  ; testCase
    "Bob's token should be satisfied"
    (expectTrue (tokenLogic Unbound aliceTokenOwnedByAlice balancedTx))
  ; testCase
    "Bob's intent should be satisfied"
    (expectTrue (tokenLogic Unbound bobSwapIntentResource balancedTx))
  ];

main : IO := runTestSuite (testSuite "Swap Tests" tests);
