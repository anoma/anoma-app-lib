module Utils.Counter.Transaction;

import Stdlib.Prelude open;
import Stdlib.Data.Set as Set open using {Set};
import Anoma.Resource open;
import Anoma.Identity open;
import Anoma.Transaction open;
import Anoma.Utils open;
import Anoma.Builtin.System open;

import AnomaHelpers open;
import Resource.Error open;
import Authorization.Message open;
import Authorization.Identities open;
import Utils.Dummy.Resource open;
import Utils.Counter.Label open;
import Utils.Counter.Resource open;

import AnomaHelpers open;

--- Requires a consumable `Utils.Dummy.Resource`.
createCounter
  (standardInputs : StandardInputs)
  (consumableDummy : Resource)
  : Result StandardError Transaction :=
  let
    identity := StandardInputs.identity standardInputs;
    nullifierKey := standardInputs |> StandardInputs.identity |> toNullifierKey;
    ephDummy : Resource :=
      alwaysValidResource@{
        quantity := 1;
        identity;
        ephemeral := true
      };
  in if
    | kind consumableDummy /= kind ephDummy :=
      throw
        mkDefaultError@{
          msg := "The oked consumable resource has the wrong kind."
        }
    | else :=
      let
        ephCounter : Resource :=
          mkCounter@{
            identity;
            ephemeral := true;
            uniqueLabel := mkCounterLabel (nullifier nullifierKey consumableDummy);
            count := 0
          };
        newCounter :=
          mkCounter@{
            identity := Universal.identity;
            ephemeral := false;
            uniqueLabel := mkCounterLabel (nullifier (Universal.nullifierKey) consumableDummy);
            count := 0
          };
      in ok
        mkTransactionHelper@{
          roots := Set.fromList [StandardInputs.currentRoot standardInputs];
          actions :=
            Set.singleton
              mkActionHelper@{
                identity := StandardInputs.identity standardInputs;
                consumed := Set.fromList [consumableDummy; ephCounter];
                created := Set.fromList [ephDummy; newCounter];
                appData := Set.empty;
                customInputs := Set.empty
              }
        };

incrementCounter (standardInputs : StandardInputs) (currentCounter : Resource) : Transaction :=
  let
    updatedCounter : Resource :=
      mkCounter@{
        identity := Universal.identity;
        ephemeral := false;
        uniqueLabel := get currentCounter;
        count :=
          (currentCounter |> Resource.valueRef |> Ref.fromRef |> Value.unValue |> anomaDecode) + 1
      };
    appData :=
      mkResourceRelationshipAppData@{
        identity := Universal.identity;
        origins := Set.singleton currentCounter;
        mustBeConsumed := Set.empty;
        mustBeCreated := Set.singleton updatedCounter
      };
  in mkTransactionHelper@{
    roots := Set.fromList [StandardInputs.currentRoot standardInputs];
    actions :=
      Set.singleton
        mkActionHelper@{
          identity := Universal.identity;
          consumed := Set.singleton currentCounter;
          created := Set.singleton updatedCounter;
          appData;
          customInputs := Set.empty
        }
  };
