module Utils.Counter.Transaction;

import Stdlib.Prelude open;
import Data.Set as Set open using {Set};
import Anoma.Resource open;
import Anoma.Identity open;
import Anoma.Transaction open;
import Anoma.Utils open;
import Anoma.Builtin.System open;

import AnomaHelpers open;
import Resource.Error open;
import Authorization.Message open;
import Authorization.Identities open;
import Utils.Dummy.Resource open;
import Utils.Counter.Label open;
import Utils.Counter.Resource open;

--- Requires a consumable `Utils.Dummy.Resource`.
createCounter (self : Identity) (consumableDummy : Resource) : Result StandardError Transaction :=
  let
    nullifierKeyCommitment := toNullifierKeyCommitment self;
    ephDummy : Resource :=
      mkDummy@{
        nullifierKeyCommitment;
        ephemeral := true
      };
  in if
    | kind consumableDummy /= kind ephDummy :=
      throw
        mkDefaultError@{
          msg := "The oked consumable resource has the wrong kind."
        }
    | else :=
      let
        ephCounter : Resource :=
          mkCounter@{
            nullifierKeyCommitment;
            ephemeral := true;
            uniqueLabel := mkCounterLabel (nullifier consumableDummy (toNullifierKey self));
            count := 0
          };
        newCounter :=
          mkCounter@{
            nullifierKeyCommitment := Universal.nullifierKeyCommitment;
            ephemeral := false;
            uniqueLabel := mkCounterLabel (nullifier consumableDummy (Universal.nullifierKey));
            count := 0
          };
      in ok
        (mkTransactionHelper self [consumableDummy; ephCounter] [ephDummy; newCounter] Set.empty);

incrementCounter (currentCounter : Resource) : Transaction :=
  let
    updatedCounter : Resource :=
      mkCounter@{
        nullifierKeyCommitment := Universal.nullifierKeyCommitment;
        ephemeral := false;
        uniqueLabel := get currentCounter;
        count :=
          (currentCounter |> Resource.valueRef |> Ref.fromRef |> Value.unValue |> anomaDecode) + 1
      };
    extra :=
      Set.fromList
        [ mkResourceRelationshipExtraDataMapEntry@{
          nullifierKey := Universal.nullifierKey;
          origin := currentCounter;
          mustBeConsumed := [];
          mustBeCreated := [updatedCounter]
        }
        ];
  in mkTransactionHelper Universal.identity [currentCounter] [updatedCounter] extra;
