module Utils.Counter.Transaction;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open;
import Stdlib.Debug.Trace open;
import Stdlib.Data.Set as Set open using {Set};
import Anoma.Resource open;
import Anoma.Identity open;
import Anoma.Transaction open;
import Anoma.Utils open;
import Anoma.Builtin.System open;
import Anoma.Proving.Types open;

import AnomaHelpers open;
import Resource.Error open;
import Authorization.Message open;
import Authorization.Identities open;
import Utils.Dummy.Resource open;
import Utils.Counter.Label open;
import Utils.Counter.Resource open;

import AnomaHelpers open;

-- TODO use general initialize/traits
--- Requires a consumable resource, e.g., `Utils.Dummy.Resource`.
createCounter
  (standardInputs : StandardInputs) (consumable : Resource) : Result StandardError Transaction :=
  let
    identity := StandardInputs.identity standardInputs;
    ephConsumable : Resource := consumable@Resource{ephemeral := true};
    uniqueLabel := createUniqueCounterLabel consumable;
    ephCounter : Resource :=
      mkCounter@{
        identity;
        ephemeral := true;
        uniqueLabel;
        count := 0
      };
    newCounter :=
      mkCounter@{
        identity;
        ephemeral := false;
        uniqueLabel;
        count := 0
      };
    consumed := Set.fromList [consumable; ephCounter];
    created := Set.fromList [ephConsumable; newCounter];

    commitmentCustomInputs := computableComponentToCustomInputs commitment created;
    nullifierCustomInputs :=
      computableComponentToCustomInputs (nullifier (toNullifierKey identity)) consumed;

    commitments :=
      Set.map (key in Map.keys (AppDataMap.fromSet (commitmentCustomInputs)))
        {anomaDecode (AppDataKey.unAppDataKey key)};
    nullifiers :=
      Set.map (key in Map.keys (AppDataMap.fromSet (nullifierCustomInputs)))
        {anomaDecode (AppDataKey.unAppDataKey key)};

  in ok
    mkTransactionHelper@{
      roots := Set.singleton (StandardInputs.currentRoot standardInputs);
      actions :=
        Set.singleton
          mkActionHelper@{
            identity := StandardInputs.identity standardInputs;
            consumed;
            created;
            appData := Set.empty;
            customInputs := Set.union commitmentCustomInputs nullifierCustomInputs;
            maybeNullifiers := just nullifiers;
            maybeCommitments := just commitments
          }
    };

incrementCounter (standardInputs : StandardInputs) (currentCounter : Resource) : Transaction :=
  let
    identity := StandardInputs.identity standardInputs;
    updatedCounter : Resource :=
      mkCounter@{
        identity;
        ephemeral := false;
        uniqueLabel := getCounterLabel currentCounter;
        count :=
          (currentCounter |> Resource.valueRef |> Ref.fromRef |> Value.unValue |> anomaDecode) + 1
      };
    consumed := Set.singleton currentCounter;
    created := Set.singleton updatedCounter;

  in mkTransactionHelper@{
    roots := Set.singleton (StandardInputs.currentRoot standardInputs);
    actions :=
      Set.singleton
        mkActionHelper@{
          identity;
          consumed := Set.singleton currentCounter;
          created := Set.singleton updatedCounter;
          appData := Set.empty;
          customInputs := Set.empty
        }
  };
