module Utils.Counter.Logic;

import Stdlib.Prelude open;
import Anoma.Identity open;
import Anoma.Resource open;
import Anoma.Proving.Types open;
import AnomaHelpers open;

import Utils.Counter.Count open;
import Utils.Counter.Label open;
import Utils.Counter.Extra open;

import Resource.Traits open;
import Authorization.Identities open;

counterLogic (publicInputs : Logic.Instance) (privateInputs : Logic.Witness) : Bool :=
  let
    tag := Logic.Instance.tag publicInputs;
    lookupResource {A} (key : A) : Maybe Resource :=
      lookupCustomInputs@{
        key;
        customInputs := Logic.Witness.customInputs privateInputs
      };
  in case tag of
       | Logic.Consumed nullifier :=
         case lookupResource nullifier of {
           | nothing := false
           | just self :=
             case HasEphemerality.get self of {
               | Ephemeral := initializationLogic nullifier self publicInputs
               | NonEphemeral := incrementationLogic self publicInputs privateInputs
             }
         }
       | Logic.Created commitment :=
         case lookupResource commitment of
           | nothing := false
           | just self :=
             case HasEphemerality.get self of
               | Ephemeral := false
               | NonEphemeral := true;

initializationLogic
  (nullifier : Nullifier) (self : Resource) (publicInputs : Logic.Instance) : Bool :=
  HasQuantity.get self == 1
    && isNullifierPresent@{
      nullifier;
      nullifierSet := Logic.Instance.nullifiers publicInputs
    };

-- TODO use pattern matching
incrementationLogic
  (self : Resource) (publicInputs : Logic.Instance) (privateInputs : Logic.Witness) : Bool :=
  case
    findCreatedCounter@{
      consumedCounter := self;
      publicInputs;
      privateInputs
    }
  of
    | just foundCounter := isIncremented self foundCounter
    | nothing := false;
