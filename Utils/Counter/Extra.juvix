module Utils.Counter.Extra;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open using {failwith};
import Data.Set as Set open using {Set};
import Anoma.Resource open;
import Anoma.Transaction open;
import Anoma.Proving.Types open;

import AnomaHelpers open;

import Authorization.Message open;
import Utils.Counter.Count open;

-- TODO use nullifier instead of commitment
-- TODO Refactor by using actions.
findCreatedCounter
  (consumedCounter : Resource)
  (publicInputs : ResourceLogic.Instance)
  (privateInputs : ResourceLogic.Witness)
  : Maybe Resource :=
  let
    cm := commitment consumedCounter;
  in case
       lookupAppData@{
         -- TODO use a different lookup key
         key := cm;
         Value := ResourceRelationship;
         appData := ResourceLogic.Instance.appData publicInputs
       }
     of
       | nothing := nothing
       | just msg :=
         case
           Set.toList (ResourceRelationship.mustBeConsumed msg)
             , Set.toList (ResourceRelationship.mustBeCreated msg)
         of
           | nil, [foundCm] :=
             let
               created := ResourceLogic.Witness.created privateInputs;
               maybeCounter : Maybe Resource :=
                 findCreatedResource@{
                   commitment := foundCm;
                   resources := created
                 };
             in case maybeCounter of {
                  | nothing := nothing
                  | just foundCounter :=
                    if
                      | ResourceRelationship.origin msg == cm
                        && kind consumedCounter == kind foundCounter
                        && isCreated foundCm publicInputs := just foundCounter
                      | else := nothing
                }
           | _, _ := nothing;
