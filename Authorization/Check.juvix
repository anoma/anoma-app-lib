module Authorization.Check;

import Stdlib.Prelude open;
import Anoma open;
import AnomaHelpers open;

import Authorization.Message open;

-- TODO use nullifer instead of commitment
isAuthorizedBy
  (signer : PublicKey)
  (self : Resource)
  (_tx : Transaction)
  : Bool :=
  let
    cm := commitment self;
  in case
       lookupExtraData@{
         key := natToBytes32 cm;
         Value := Pair ResourceRelationship Signature;
         tx := _tx
       }
     of
       | nothing := false
       | just (msg, sig) :=
         ResourceRelationship.origin msg == cm
           && anomaVerifyDetached sig msg signer
           && isSubset
             (ResourceRelationship.mustBeConsumed msg)
             (nullifierSet _tx)
           && isSubset
             (ResourceRelationship.mustBeCreated msg)
             (commitmentSet _tx);

type UnauthorizedError :=
  mkUnauthorizedError {
    expected : PublicKey;
    actual : PublicKey
  };

instance
UnauthorizedError-Show : Show UnauthorizedError :=
  mkShow
    \ {e :=
      "UnauthorizedError:\n{"
        ++str "expected : "
        ++str (e |> UnauthorizedError.expected |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> UnauthorizedError.actual |> Show.show)
        ++str "}"};
