module Authorization.Message;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open using {failwith};
import Stdlib.Data.Set as Set open using {Set; empty; size; insert; union};
import AnomaHelpers open;
import Authorization.Identities open;

import Anoma.Resource as Resource open;
import Anoma.Transaction as Transaction open;
import Anoma.Builtin.System open;
import Anoma.Transaction.AppData open;
import Anoma.Identity open;

-- TODO improve proving imports
import Anoma.Proving.Types open;
import Anoma.Proving.DeltaProof as DeltaProof open;
import Anoma.Proving.ComplianceProof as ComplianceProof open;
import Anoma.Proving.LogicProof as LogicProof open;
import Anoma.Proving.ProofRecord as GenericProofRecord open;
import Anoma.Utils open;

--- A message format specifiying resources that must be created and consumed within an ;Action;.
--- @param origin The resource performing the check.
--- @mustBeCreated origin The resource performing the check.
--- @mustBeConsumed origin The resource performing the check.
type ResourceRelationship :=
  mkResourceRelationship@{
    origin : Logic.Tag;
    mustBeConsumed : Set Nullifier;
    mustBeCreated : Set Commitment
  };

mkResourceRelationshipAppDataEntry
  -- TODO use Witness here
  (identity : Identity)
  (origin : Logic.Tag)
  (mustBeConsumed : Set Nullifier)
  (mustBeCreated : Set Commitment)
  : AppDataEntry :=
  let
    msg : ResourceRelationship :=
      mkResourceRelationship@{
        origin;
        mustBeConsumed;
        mustBeCreated
      };
    sig : Signature := sign msg (Identity.internal identity);
  in case origin of
       | Logic.Created commitment :=
         mkAppDataEntry@{
           key := commitment |> anomaEncode |> mkAppDataKey;
           value := (msg, sig) |> anomaEncode |> mkAppDataValue
         }
       | Logic.Consumed nullifier :=
         mkAppDataEntry@{
           key := nullifier |> anomaEncode |> mkAppDataKey;
           value := (msg, sig) |> anomaEncode |> mkAppDataValue
         };

module FromConvertable;
  import Resource.Traits.Convertable open;
  import Transaction.Traits open;

  --- Creates an app data map entry for every consumed ;Convertable; ;Resource; of type `R1` with a ;ResourceRelationship; message and signature being stored at the consumed resources commitment  message. This message must be signed by the respective owner of the consumed resources and requires  all created ;Convertable; ;Resource; of type `R2` to be present in the ;Commitment; ;Set; of the transaction.
  actionWithAuthorizationAppData
    {R1 R2} {{Convertable R1}} {{Convertable R2}} : ActionConvertable R1 R2 :=
    mkActionConvertable@{
      toAction
        (standardInputs : StandardInputs)
        (consumedResources : Set R1)
        (createdResources : Set R2)
        : Action :=
        let
          identity := StandardInputs.identity standardInputs;
          consumed := Set.fromList (map Convertable.toResource (Set.toList consumedResources));
          created := Set.fromList (map Convertable.toResource (Set.toList createdResources));

          commitmentCustomInputs := computableComponentToCustomInputs commitment created;
          nullifierCustomInputs :=
            computableComponentToCustomInputs (nullifier (toNullifierKey identity)) consumed;

          commitments :=
            Set.fromList
              (map
                (AppDataKey.unAppDataKey >> anomaDecode)
                (commitmentCustomInputs |> AppDataMap.fromSet |> Map.keys |> Set.toList));
          nullifiers :=
            Set.fromList
              (map
                (AppDataKey.unAppDataKey >> anomaDecode)
                (nullifierCustomInputs |> AppDataMap.fromSet |> Map.keys |> Set.toList));

          customInputs := Set.union commitmentCustomInputs commitmentCustomInputs;
          -- consumed := map (r in consumedResources) {Convertable.toResource r};
          -- created := map (r in createdResources) {Convertable.toResource r};
          -- TODO Raise juvix issue that `map (origin in consumed)` doesn't work. ("No trait instance found for Functor Set")
          appData :=
            for (acc := Set.empty) (nullifier in nullifiers)
              {Set.insert
                mkResourceRelationshipAppDataEntry@{
                  identity;
                  origin := Logic.Consumed nullifier;
                  mustBeConsumed := Set.empty;
                  mustBeCreated := commitments
                }
                acc};

        in mkActionHelper@{
          identity;
          consumed;
          created;
          appData;
          customInputs;
          maybeNullifiers := just nullifiers;
          maybeCommitments := just commitments
        }
    };

end;
