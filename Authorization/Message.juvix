module Authorization.Message;

import Stdlib.Prelude open;
import Data.Map as Map open using {Map; empty};
import Data.Set as Set open using {Set; empty};
import Anoma open;
import AnomaHelpers open;

-- TODO use Nullifier once we comply with v2 specs
type ResourceRelationship :=
  mkResourceRelationship {
    origin : Commitment;
    mustBeCreated : Set Commitment;
    mustBeConsumed : Set Nullifier
  };

mkResourceRelationshipExtraDataMapEntry
  (nullifierKey : PrivateKey)
  (mustBeConsumed : List Resource)
  (mustBeCreated : List Resource)
  (origin : Resource)
  : Pair Bytes32 Bytes :=
  let
    originCm : Commitment := commitment origin;
    consumedNfs : Set Nullifier :=
      Set.fromList (map \ {r := nullifier r nullifierKey} mustBeConsumed);
    createdCms : Set Commitment := Set.fromList (map commitment mustBeCreated);
    msg : ResourceRelationship :=
      mkResourceRelationship@{
        origin := originCm;
        mustBeConsumed := consumedNfs;
        mustBeCreated := createdCms
      };
    sig := anomaSignDetached msg nullifierKey;
  in (originCm, msg, sig) |> mkExtraDataEntry;

mkResourceRelationshipExtraData
  (nullifierKey : PrivateKey)
  (origins : List Resource)
  (mustBeConsumed : List Resource)
  (mustBeCreated : List Resource)
  : Map Bytes32 Bytes :=
  Map.fromList
    (map
      (mkResourceRelationshipExtraDataMapEntry nullifierKey mustBeConsumed mustBeCreated)
      origins);

module FromConvertable;
  import Resource.Traits.Convertable open;
  import Transaction.Traits open;

  --- Creates an extra data map entry for every consumed ;Convertable; ;Resource; of type `R1` with a ;ResourceRelationship; message and signature being stored at the consumed resources commitment  message. This message must be signed by the respective owner of the consumed resources and requires  all created ;Convertable; ;Resource; of type `R2` to be present in the ;Commitment; ;Set; of the transaction.
  transactionWithAuthorizationExtraData
    {R1 R2} {{Convertable R1}} {{Convertable R2}} : TransactionConvertable R1 R2 :=
    mkTransactionConvertable@{
      toTransaction (nk : PrivateKey) (consumedR1 : List R1) (createdR2 : List R2) : Transaction :=
        let
          consumed := map Convertable.toResource consumedR1;
          created := map Convertable.toResource createdR2;
        in mkTransaction@{
          nullifierKey := nk;
          consumed;
          created;
          extraData :=
            mkResourceRelationshipExtraData@{
              nullifierKey := nk;
              origins := consumed;
              mustBeConsumed := [];
              mustBeCreated := created
            }
        }
    };

end;
