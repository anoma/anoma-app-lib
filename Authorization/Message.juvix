module Authorization.Message;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open using {failwith};
import Data.Map as Map open using {Map; empty};
import Data.Set as Set open using {Set; empty; insert};
import AnomaHelpers open;
import Authorization.Identities open;

-- TODO fix imports
import Anoma.Resource as Resource open;
import Anoma.Transaction as Transaction open;
import Anoma.Builtin.System open;
import Anoma.Builtin.ByteArray open;
import Anoma.Transaction.AppData open;
import Anoma.Identity open;

import Anoma.Proving.Types open;
import Anoma.Proving.DeltaProof as DeltaProof open;
import Anoma.Proving.ComplianceProof as ComplianceProof open;
import Anoma.Proving.LogicProof as LogicProof open;
import Anoma.Proving.ProofRecord as Generic open;

import Anoma.Utils open;

-- TODO use Nullifier once we comply with v2 specs
type ResourceRelationship :=
  mkResourceRelationship {
    origin : Commitment;
    mustBeCreated : Set Commitment;
    mustBeConsumed : Set Nullifier
  };

mkResourceRelationshipAppDataMapEntry
  -- TODO use Witness here
  (nullifierKey : Resource.NullifierKey)
  (mustBeConsumed : Set Resource)
  (mustBeCreated : Set Resource)
  (origin : Resource)
  : AppDataEntry :=
  let
    originCm : Resource.Commitment := commitment origin;
    consumedNfs : Set Resource.Nullifier :=
      Set.fromList (map \ {r := nullifier nullifierKey r} (Set.toList mustBeConsumed));
    createdCms : Set Resource.Commitment :=
      Set.fromList (map commitment (Set.toList mustBeCreated));
    msg : ResourceRelationship :=
      mkResourceRelationship@{
        origin := originCm;
        mustBeConsumed := consumedNfs;
        mustBeCreated := createdCms
      };
    sig : ByteArray := anomaSignDetached msg (NullifierKey.unNullifierKey nullifierKey);
  in mkAppDataEntry@{
    key := anomaEncode originCm |> mkAppDataKey;
    value := anomaEncode (msg, sig) |> mkAppDataValue
  };

--- TODO revisit
mkResourceRelationshipAppData
  (nullifierKey : Resource.NullifierKey)
  (origins : Set Resource)
  (mustBeConsumed : Set Resource)
  (mustBeCreated : Set Resource)
  : AppData :=
  Set.fromList
    (map
      (mkResourceRelationshipAppDataMapEntry nullifierKey mustBeConsumed mustBeCreated)
      (Set.toList origins));

createLogicProofRecord
  (tag : Logic.Tag)
  (publicInputs : Logic.Instance)
  (privateInputs : Logic.Witness)
  : LogicProof.ProofRecord :=
  let
    provingKey :=
      case tag of
        | Logic.Consumed nf :=
          case
            lookupCustomInputs@{
              key := nf;
              Value := Resource;
              customInputs := Logic.Witness.customInputs privateInputs
            }
          of {
            | just resource := Logic.mkProvingKey resource
            | nothing := failwith "this should never happen"
          }

        | Logic.Created cm :=
          case
            lookupCustomInputs@{
              key := cm;
              Value := Resource;
              customInputs := Logic.Witness.customInputs privateInputs
            }
          of
            | just resource := Logic.mkProvingKey resource
            | nothing := failwith "this should never happen";
    proof : Logic.Proof :=
      LogicProof.prove@{
        provingKey;
        publicInputs;
        privateInputs
      };
    verifyingKey := Logic.mkVerifyingKey unit;
  in verifyingKey, proof, publicInputs;

createComplianceProofRecord : ComplianceProof.ProofRecord :=
  let
    verifyingKey := Compliance.mkVerifyingKey unit;
    provingKey := Compliance.mkProvingKey unit;
    publicInputs := Compliance.mkInstance unit;
    privateInputs := Compliance.mkWitness unit;
    proof :=
      ComplianceProof.prove@{
        provingKey;
        publicInputs;
        privateInputs
      };
  in verifyingKey, proof, publicInputs;

--- This expects ;NullifierKey; to be present in the ;Logic.CustomInputs; with the encoded ;Resource; plaintext as the lookup key.
--- If the resource is not present, ;Universal.nullifierKey; is used instead.
mkActionHelper
  (nullifierKey : NullifierKey)
  (consumed : Set Resource)
  (created : Set Resource)
  (appData : AppData)
  : Action :=
  let
    nullifiers := Set.fromList (map (nullifier nullifierKey) (Set.toList consumed));
    commitments := Set.fromList (map commitment (Set.toList created));
    tags : List Logic.Tag :=
      map Logic.Consumed (Set.toList nullifiers) ++ map Logic.Created (Set.toList commitments);
    appData :=
      mkResourceRelationshipAppData@{
        nullifierKey;
        origins := consumed;
        mustBeConsumed := Set.empty;
        mustBeCreated := created
      };

    -- `Map Nullifier ConsumedResource` ++ `Map Commitment CreatedResource`
    customInputs :=
      Set.fromList
        (map
            \ {r :=
              mkAppDataEntry@{
                key := r |> nullifier nullifierKey |> anomaEncode |> mkAppDataKey;
                value := r |> anomaEncode |> mkAppDataValue
              }}
            (Set.toList consumed)
          ++ map
            \ {r :=
              mkAppDataEntry@{
                key := r |> commitment |> anomaEncode |> mkAppDataKey;
                value := r |> anomaEncode |> mkAppDataValue
              }}
            (Set.toList created));

    privateInputs :=
      Logic.mkWitness@{
        created;
        consumed;
        customInputs
      };

    logicProofs : Set LogicProof.ProofRecord :=
      for (acc := Set.empty) (tag in tags)
        {let
          publicInputs :=
            Logic.mkInstance@{
              tag;
              commitments;
              nullifiers;
              appData
            };
        in Set.insert
          createLogicProofRecord@{
            tag;
            publicInputs;
            privateInputs
          }
          acc};

    complianceProofs : Set ComplianceProof.ProofRecord :=
      listFor (acc := Set.empty) (tag in tags) {Set.insert createComplianceProofRecord acc};

  in mkAction@{
    commitments;
    nullifiers;
    proofs :=
      Set.fromList
        (map Generic.proofRecordLogic (Set.toList logicProofs)
          ++ map Generic.proofRecordLogic (Set.toList logicProofs));
    appData
  };

module FromConvertable;
  import Resource.Traits.Convertable open;
  import Transaction.Traits open;

  --- Creates an extra data map entry for every consumed ;Convertable; ;Resource; of type `R1` with a ;ResourceRelationship; message and signature being stored at the consumed resources commitment  message. This message must be signed by the respective owner of the consumed resources and requires  all created ;Convertable; ;Resource; of type `R2` to be present in the ;Commitment; ;Set; of the transaction.
  transactionWithAuthorizationAppData
    {ConsumedResource CreatedResource}
    {{Convertable ConsumedResource}}
    {{Convertable CreatedResource}}
    : TransactionConvertable ConsumedResource CreatedResource :=
    mkTransactionConvertable@{
      toTransaction
        (standardInputs : StandardInputs)
        (consumedResources : List ConsumedResource)
        (createdResources : List CreatedResource)
        : Transaction.Transaction :=
        -- TODO: Nullifier Computation. Provide a key for each resources vs.
        let
          consumed := Set.fromList (map Convertable.toResource consumedResources);
          created := Set.fromList (map Convertable.toResource createdResources);
          nullifierKey :=
            standardInputs
              |> StandardInputs.identity
              |> Identity.internal
              |> InternalIdentity.unInternalIdentity
              |> mkNullifierKey;
          appData :=
            mkResourceRelationshipAppData@{
              nullifierKey;
              origins := consumed;
              mustBeConsumed := Set.empty;
              mustBeCreated := created
            };
        in mkTransactionHelper@{
          roots := Set.fromList [StandardInputs.currentRoot standardInputs];
          actions :=
            Set.fromList
              [ mkActionHelper@{
                nullifierKey;
                consumed;
                created;
                appData
              }
              ]
        }
    };
end;

{-
proofs : Set Generic.ProofRecord :=
      listFor (acc := Set.empty) (tag in tags)
        {case tag of
          | Logic.Consumed nf :=
            let
              publicInputs : Logic.Instance :=
                Logic.mkInstance@{
                  tag;
                  commitments;
                  nullifiers;
                  appData
                };
              proof : Logic.Proof :=
                LogicProof.prove@{
                  provingKey :=
                    case
                      lookupCustomInputs@{
                        key := nf;
                        Value := Resource;
                        customInputs
                      }
                    of
                      | just resource := Logic.mkProvingKey resource
                      | nothing := failwith "this should never happen";
                  publicInputs;
                  privateInputs
                };
              verifyingKey := Logic.mkVerifyingKey unit;
            in Set.insert (Generic.proofRecordLogic (verifyingKey, proof, publicInputs)) acc
          | Logic.Created cm :=
            let
              publicInputs : Logic.Instance :=
                Logic.mkInstance@{
                  tag;
                  commitments;
                  nullifiers;
                  appData
                };
              proof : Logic.Proof :=
                LogicProof.prove@{
                  provingKey :=
                    case
                      lookupCustomInputs@{
                        key := cm;
                        Value := Resource;
                        customInputs
                      }
                    of
                      | just resource := Logic.mkProvingKey resource
                      | nothing := failwith "this should never happen";
                  publicInputs;
                  privateInputs
                };
              verifyingKey := Logic.mkVerifyingKey unit;
            in Set.insert (Generic.proofRecordLogic (verifyingKey, proof, publicInputs)) acc};

-}
