module Authorization.Message;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open using {failwith};
import Data.Map as Map open using {Map; empty};
import Data.Set as Set open using {Set; empty; insert; union};
import AnomaHelpers open;
import Authorization.Identities open;

-- TODO fix imports
import Anoma.Resource as Resource open;
import Anoma.Transaction as Transaction open;
import Anoma.Builtin.System open;
import Anoma.Builtin.ByteArray open using {ByteArray};
import Anoma.Transaction.AppData open;
import Anoma.Identity open;

-- TODO improve proving imports
import Anoma.Proving.Types open;
import Anoma.Proving.DeltaProof as DeltaProof open;
import Anoma.Proving.ComplianceProof as ComplianceProof open;
import Anoma.Proving.LogicProof as LogicProof open;
import Anoma.Proving.ProofRecord as GenericProofRecord open;

import Anoma.Utils open;

-- TODO use Nullifier once we comply with v2 specs
type ResourceRelationship :=
  mkResourceRelationship {
    origin : Commitment;
    mustBeCreated : Set Commitment;
    mustBeConsumed : Set Nullifier
  };

mkResourceRelationshipAppDataMapEntry
  -- TODO use Witness here
  (nullifierKey : Resource.NullifierKey)
  (mustBeConsumed : Set Resource)
  (mustBeCreated : Set Resource)
  (origin : Resource)
  : AppDataEntry :=
  let
    originCm : Resource.Commitment := commitment origin;
    consumedNfs : Set Resource.Nullifier :=
      Set.fromList (map \ {r := nullifier nullifierKey r} (Set.toList mustBeConsumed));
    createdCms : Set Resource.Commitment :=
      Set.fromList (map commitment (Set.toList mustBeCreated));
    msg : ResourceRelationship :=
      mkResourceRelationship@{
        origin := originCm;
        mustBeConsumed := consumedNfs;
        mustBeCreated := createdCms
      };
    sig : ByteArray := anomaSignDetached msg (NullifierKey.unNullifierKey nullifierKey);
  in mkAppDataEntry@{
    key := anomaEncode originCm |> mkAppDataKey;
    value := anomaEncode (msg, sig) |> mkAppDataValue
  };

--- TODO revisit
mkResourceRelationshipAppData
  (nullifierKey : Resource.NullifierKey)
  (origins : Set Resource)
  (mustBeConsumed : Set Resource)
  (mustBeCreated : Set Resource)
  : AppData :=
  Set.fromList
    (map
      (mkResourceRelationshipAppDataMapEntry nullifierKey mustBeConsumed mustBeCreated)
      (Set.toList origins));

findProvingKey {T} (key : T) (customInputs : Logic.CustomInputs) : Logic.ProvingKey :=
  case
    lookupCustomInputs@{
      key;
      Value := Resource;
      customInputs
    }
  of
    | just resource := Logic.mkProvingKey resource
    | nothing := failwith "this should never happen";

createLogicProofRecord
  (tag : Logic.Tag)
  (publicInputs : Logic.Instance)
  (privateInputs : Logic.Witness)
  : GenericProofRecord.ProofRecord :=
  let
    customInputs := Logic.Witness.customInputs privateInputs;
    provingKey :=
      case tag of
        | Logic.Consumed nf := findProvingKey nf customInputs
        | Logic.Created cm := findProvingKey cm customInputs;
    proof : Logic.Proof :=
      LogicProof.prove@{
        provingKey;
        publicInputs;
        privateInputs
      };
    verifyingKey := Logic.mkVerifyingKey unit;
  in GenericProofRecord.Logic (verifyingKey, proof, publicInputs);

createComplianceProofRecord : GenericProofRecord.ProofRecord :=
  let
    verifyingKey := Compliance.mkVerifyingKey unit;
    provingKey := Compliance.mkProvingKey unit;
    publicInputs := Compliance.mkInstance unit;
    privateInputs := Compliance.mkWitness unit;
    proof :=
      ComplianceProof.prove@{
        provingKey;
        publicInputs;
        privateInputs
      };
  in GenericProofRecord.Compliance (verifyingKey, proof, publicInputs);

computableComponentToResourceMap
  {A} (f : Resource -> A) (resources : Set Resource) : Logic.CustomInputs :=
  Set.fromList
    (map
      \ {r :=
        mkAppDataEntry@{
          key := r |> f |> anomaEncode |> mkAppDataKey;
          value := r |> anomaEncode |> mkAppDataValue
        }}
      (Set.toList resources));

module FromConvertable;
  import Resource.Traits.Convertable open;
  import Transaction.Traits open;

  --- Creates an app data map entry for every consumed ;Convertable; ;Resource; of type `R1` with a ;ResourceRelationship; message and signature being stored at the consumed resources commitment  message. This message must be signed by the respective owner of the consumed resources and requires  all created ;Convertable; ;Resource; of type `R2` to be present in the ;Commitment; ;Set; of the transaction.
  actionWithAuthorizationAppData
    {R1 R2} {{Convertable R1}} {{Convertable R2}} : ActionConvertable R1 R2 :=
    mkActionConvertable@{
      toAction
        (standardInputs : StandardInputs)
        (consumedResources : List R1)
        (createdResources : List R2)
        : Action :=
        let
          nullifierKey :=
            standardInputs
              |> StandardInputs.identity
              |> Identity.internal
              |> InternalIdentity.unInternalIdentity
              |> mkNullifierKey;
          consumed := Set.fromList (map Convertable.toResource consumedResources);
          created := Set.fromList (map Convertable.toResource createdResources);

          nullifiers := Set.fromList (map (nullifier nullifierKey) (Set.toList consumed));
          commitments := Set.fromList (map commitment (Set.toList created));
          tags : List Logic.Tag :=
            map Logic.Consumed (Set.toList nullifiers)
              ++ map Logic.Created (Set.toList commitments);
          appData :=
            mkResourceRelationshipAppData@{
              nullifierKey;
              origins := consumed;
              mustBeConsumed := Set.empty;
              mustBeCreated := created
            };

          customInputs :=
            Set.union
              (computableComponentToResourceMap commitment created)
              (computableComponentToResourceMap (nullifier nullifierKey) consumed);

          privateInputs :=
            Logic.mkWitness@{
              created;
              consumed;
              customInputs
            };

          logicProofs : Set GenericProofRecord.ProofRecord :=
            Set.fromList
              (map
                \ {tag :=
                  createLogicProofRecord@{
                    tag;
                    publicInputs :=
                      Logic.mkInstance@{
                        tag;
                        commitments;
                        nullifiers;
                        appData
                      };
                    privateInputs
                  }}
                tags);

          complianceProofs : Set GenericProofRecord.ProofRecord :=
            Set.fromList (replicate (length tags) (createComplianceProofRecord));
        in mkAction@{
          commitments;
          nullifiers;
          proofs := Set.union logicProofs complianceProofs;
          appData
        }
    };
end;
