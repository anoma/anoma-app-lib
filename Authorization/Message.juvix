module Authorization.Message;

import Stdlib.Prelude open;
import Data.Map as Map open using {Map; empty};
import Data.Set as Set open using {Set; insert; delete};
import Anoma as MyAnoma open;
import AnomaHelpers open;
import Token.Indexing open;

-- TODO use Nullifier once we comply with v2 specs
type ResourceRelationship :=
  mkResourceRelationship {
    origin : Commitment;
    mustBeCreated : Set Commitment;
    mustBeConsumed : Set Nullifier
  };

-- TODO make signing optional
mkResourceRelationshipExtraDataMapEntry
  (nullifierKey : PrivateKey)
  (mustBeConsumed : List Resource)
  (mustBeCreated : List Resource)
  (origin : Resource)
  : Pair Bytes32 Bytes :=
  let
    originCm : Commitment := commitment origin;
    consumedNfs : Set Nullifier :=
      Set.fromList (map \ {r := nullifier r nullifierKey} mustBeConsumed);
    createdCms : Set Commitment := Set.fromList (map commitment mustBeCreated);
    msg : ResourceRelationship :=
      mkResourceRelationship@{
        origin := originCm;
        mustBeConsumed := consumedNfs;
        mustBeCreated := createdCms
      };
    k : Bytes32 := natToBytes32 (anomaEncode originCm);
    v : Bytes := natToBytes (anomaEncode (msg, anomaSignDetached msg nullifierKey));
  in k, v;

mkResourceRelationshipExtraData
  (nullifierKey : PrivateKey)
  (origins : List Resource)
  (mustBeConsumed : List Resource)
  (mustBeCreated : List Resource)
  : Map Bytes32 Bytes :=
  Map.fromList
    (map
      (mkResourceRelationshipExtraDataMapEntry nullifierKey mustBeConsumed mustBeCreated)
      origins);

-- Creates a ;List TokenAssignment; to be processed by the Anoma node client.
prepareAssignments (consumed : List Resource) (created : List Resource) : List TokenAssignment :=
  let
    nonEphConsumed := filter \ {r := not (isEphemeral r)} consumed;
    nonEphCreated := filter \ {r := not (isEphemeral r)} created;

    -- Get the current ledger entries associated with all kinds and accounts involved in this transaction.
    ledger : LedgerMapping := getLedgerMapping (nonEphConsumed ++ nonEphCreated);
    -- Replace the ;Set Commitment; in the mapping with one, where the consumed resource commitments have been removed.
    ledgerWithoutConsumed : LedgerMapping :=
      for (acc := ledger) (r in nonEphConsumed)
        {let
          kind := anomaKind r;
          account := Resource.npk r;
          cm := commitment r;
        in case Map.lookup kind acc of
             | nothing := acc
             | just outer :=
               case Map.lookup account outer of
                 | nothing := acc
                 | just inner :=
                   Map.insert kind (Map.insert account (Set.delete cm inner) outer) acc};
    -- Replace the ;Set Commitment; in the mapping with one, where the created resource commitments have been added.
    ledgerWithoutConsumedWithCreated : LedgerMapping :=
      for (acc := ledgerWithoutConsumed) (r in nonEphCreated)
        {let
          kind := anomaKind r;
          account := Resource.npk r;
          cm := commitment r;
        in case Map.lookup kind acc of
             | nothing := acc
             | just outer :=
               case Map.lookup account outer of
                 | nothing := acc
                 | just inner :=
                   Map.insert kind (Map.insert account (Set.insert cm inner) outer) acc};
  in for (outerAcc := []) (outerKey, outerVal in Map.toList ledgerWithoutConsumedWithCreated)
       {for (innerAcc := []) (innerKey, innerVal in Map.toList outerVal)
         {outerAcc
           ++ [ KeyValue.assign@{
                key :=
                  KeyValue.mkKey
                    (map
                      natToString
                      [MyAnoma.Kind.unKind outerKey; PublicKey.unPublicKey innerKey]);
                value := innerVal
              }
              ]}};

mkTxWithExtraData
  (nk : PrivateKey)
  (consumed : List Resource)
  (created : List Resource)
  : TxData (Set Commitment) :=
  mkTxData@{
    tx :=
      Transaction.mk@{
        roots := [];
        commitments := map commitment created;
        nullifiers := map (r in consumed) nullifier r nk;
        proofs := consumed ++ created;
        complianceProofs := [];
        delta := [];
        extra :=
          anomaEncode
            mkResourceRelationshipExtraData@{
              nullifierKey := nk;
              origins := consumed;
              mustBeConsumed := [];
              mustBeCreated := created
            };
        preference := 0
      };
    assignment :=
      prepareAssignments@{
        consumed;
        created
      }
  };
