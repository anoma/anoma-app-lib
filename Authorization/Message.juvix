module Authorization.Message;

import Stdlib.Prelude open;
import Data.Map as Map open using {Map; empty};
import Data.Set as Set open using {Set; empty};
import AnomaHelpers open;
-- TODO fix imports
import Anoma.Resource as Resource open;
import Anoma.Transaction as Transaction open;
import Anoma.Builtin.System open;
import Anoma.Builtin.ByteArray open;
import Anoma.Transaction.AppData open;
import Anoma.Identity open;

-- TODO use Nullifier once we comply with v2 specs
type ResourceRelationship :=
  mkResourceRelationship {
    origin : Commitment;
    mustBeCreated : Set Commitment;
    mustBeConsumed : Set Nullifier
  };

mkResourceRelationshipAppDataMapEntry
  (nullifierKey : Resource.NullifierKey)
  (mustBeConsumed : List Resource)
  (mustBeCreated : List Resource)
  (origin : Resource)
  : AppDataEntry :=
  let
    originCm : Resource.Commitment := commitment origin;
    consumedNfs : Set Resource.Nullifier :=
      Set.fromList (map \ {r := nullifier nullifierKey r} mustBeConsumed);
    createdCms : Set Resource.Commitment := Set.fromList (map commitment mustBeCreated);
    msg : ResourceRelationship :=
      mkResourceRelationship@{
        origin := originCm;
        mustBeConsumed := consumedNfs;
        mustBeCreated := createdCms
      };
    sig : ByteArray := anomaSignDetached msg (NullifierKey.unNullifierKey nullifierKey);
  in mkAppDataEntry@{
    key := anomaEncode originCm |> mkAppDataKey;
    value := anomaEncode (msg, sig) |> mkAppDataValue
  };

--- TODO revisit
mkResourceRelationshipAppData
  (nullifierKey : Resource.NullifierKey)
  (origins : List Resource)
  (mustBeConsumed : List Resource)
  (mustBeCreated : List Resource)
  : AppData :=
  Set.fromList
    (map (mkResourceRelationshipAppDataMapEntry nullifierKey mustBeConsumed mustBeCreated) origins);

module FromConvertable;
  import Resource.Traits.Convertable open;
  import Transaction.Traits open;

  --- Creates an extra data map entry for every consumed ;Convertable; ;Resource; of type `R1` with a ;ResourceRelationship; message and signature being stored at the consumed resources commitment  message. This message must be signed by the respective owner of the consumed resources and requires  all created ;Convertable; ;Resource; of type `R2` to be present in the ;Commitment; ;Set; of the transaction.
  transactionWithAuthorizationAppData
    {ConsumedResource CreatedResource}
    {{Convertable ConsumedResource}}
    {{Convertable CreatedResource}}
    : TransactionConvertable ConsumedResource CreatedResource :=
    mkTransactionConvertable@{
      toTransaction
        (standardInputs : StandardInputs)
        (consumedResources : List ConsumedResource)
        (createdResources : List CreatedResource)
        : Transaction.Transaction :=
        -- TODO: Nullifier Computation. Provide a key for each resources vs.
        let
          consumed := map Convertable.toResource consumedResources;
          created := map Convertable.toResource createdResources;
          nullifierKey :=
            standardInputs
              |> StandardInputs.identity
              |> Identity.internal
              |> InternalIdentity.unInternalIdentity
              |> mkNullifierKey;
          appData :=
            mkResourceRelationshipAppData@{
              nullifierKey;
              origins := consumed;
              mustBeConsumed := [];
              mustBeCreated := created
            };
        in mkTransactionHelper@{
          roots := Set.fromList [StandardInputs.currentRoot standardInputs];
          actions :=
            Set.fromList
              [ mkActionHelper@{
                nullifierKey;
                consumed;
                created;
                appData
              }
              ]
        }
    };

end;
