module Authorization.Owner;

import Stdlib.Prelude open;
import Data.Map open;
import Data.Set open;
import Anoma open;

import AnomaHelpers open;

type Owner := mkOwner {owner : PublicKey};

instance
Owner-Eq : Eq Owner :=
  mkEq@{
    eq (d1 d2 : Owner) : Bool :=
      Owner.owner d1 == Owner.owner d2
  };

getOwner (r : Resource) : PublicKey :=
  Owner.owner (anomaDecode (Resource.data r));

type UnauthorizedError :=
  mkUnauthorizedError {
    expected : PublicKey;
    actual : PublicKey
  };

displayUnauthorizedError (e : UnauthorizedError) : String :=
  "UnauthorizedError:\n"
    ++str "expected: "
    ++str natToString (UnauthorizedError.expected e)
    ++str "actual: "
    ++str natToString (UnauthorizedError.actual e);

type AuthMessage :=
  mkAuthMessage {
    consumed : Helper.Nullifier;
    mustBeCreated : Set Helper.Commitment
  };

mkAuthExtraDataMapEntry
  (self : PrivateKey)
  (created : List Resource)
  (consumed : Resource)
  : Pair Bytes32 Bytes :=
  let
    consumedNk : Helper.Nullifier := nullifier consumed self;
    createdCms : Set Helper.Commitment :=
      Data.Set.fromList (map commitment created);
    msg : AuthMessage :=
      mkAuthMessage@{
        consumed := consumedNk;
        mustBeCreated := createdCms
      };

    k : Bytes32 := natToBytes32 consumedNk;
    v : Bytes :=
      natToBytes
        (anomaEncode (msg, anomaSignDetached msg self));
  in k, v;

mkAuthExtraData
  (self : PrivateKey)
  (consumed : List Resource)
  (created : List Resource)
  : Map Bytes32 Bytes :=
  Data.Map.fromList
    (map (mkAuthExtraDataMapEntry self created) consumed);

isAuthorizedByOwner
  (self : Resource) (tx : Transaction) : Bool :=
  let
    owner : PublicKey := getOwner self;
    selfNk : Helper.Commitment := commitment self;
    lookupResult : Maybe (Pair AuthMessage Signature) :=
      lookupExtraData (natToBytes32 selfNk) tx;
  in case lookupResult of
       | nothing := false
       | just (msg, sig) :=
         AuthMessage.consumed msg == selfNk
           && anomaVerifyDetached sig msg owner
           && isSubsetOfCreatedResources
             (AuthMessage.mustBeCreated msg)
             tx;

terminating
containsNonOwner (keys : List PublicKey) (owner : PublicKey) : Maybe PublicKey :=
  case keys of
    | nil := nothing
    | (k :: ks) :=
      if
        | k /= owner := just k
        | else := containsNonOwner ks owner;
