module Authorization.Owner;

import Stdlib.Prelude open;
import Data.Map open;
import Data.Set open;
import Anoma open;

import AnomaHelpers open;

type Owner := mkOwner {owner : PublicKey};

instance
Owner-Eq : Eq Owner :=
  mkEq@{
    eq (d1 d2 : Owner) : Bool :=
      Owner.owner d1 == Owner.owner d2
  };

getOwner (r : Resource) : PublicKey :=
  Owner.owner (anomaDecode (Resource.data r));

type UnauthorizedError :=
  mkUnauthorizedError {
    expected : PublicKey;
    actual : PublicKey
  };

instance
UnauthorizedError-Show : Show UnauthorizedError :=
  mkShow
    \ {e :=
      "UnauthorizedError:\n{"
        ++str "expected : "
        ++str (e |> UnauthorizedError.expected |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> UnauthorizedError.actual |> Show.show)
        ++str "}"};


type AuthMessage :=
  mkAuthMessage {
    consumed : Helper.Nullifier;
    mustBeCreated : Set Helper.Commitment
  };

mkAuthExtraDataMapEntry
  (self : PrivateKey)
  (created : List Resource)
  (consumed : Resource)
  : Pair Bytes32 Bytes :=
  let
    consumedNk : Helper.Nullifier := nullifier consumed self;
    createdCms : Set Helper.Commitment :=
      Data.Set.fromList (map commitment created);
    msg : AuthMessage :=
      mkAuthMessage@{
        consumed := consumedNk;
        mustBeCreated := createdCms
      };

    k : Bytes32 := natToBytes32 consumedNk;
    v : Bytes :=
      natToBytes
        (anomaEncode (msg, anomaSignDetached msg self));
  in k, v;

mkAuthExtraData
  (self : PrivateKey)
  (consumed : List Resource)
  (created : List Resource)
  : Map Bytes32 Bytes :=
  Data.Map.fromList
    (map (mkAuthExtraDataMapEntry self created) consumed);

isAuthorizedByOwner
  (self : Resource) (tx : Transaction) : Bool :=
  let
    owner : PublicKey := getOwner self;
    selfNk : Helper.Commitment := commitment self;
    lookupResult : Maybe (Pair AuthMessage Signature) :=
      lookupExtraData (natToBytes32 selfNk) tx;
  in case lookupResult of
       | nothing := false
       | just (msg, sig) :=
         AuthMessage.consumed msg == selfNk
           && anomaVerifyDetached sig msg owner
           && isSubset
             (AuthMessage.mustBeCreated msg)
             (commitmentSet tx);
