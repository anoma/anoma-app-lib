module Authorization.Owner;

import Stdlib.Prelude open;
import Data.Map open;
import Data.Set open;
import Anoma open;

import AnomaHelpers open;

type Owner := mkOwner {owner : PublicKey};

instance
Owner-Eq : Eq Owner :=
  mkEq@{
    eq (d1 d2 : Owner) : Bool :=
      Owner.owner d1 == Owner.owner d2
  };

getOwner (r : Resource) : PublicKey :=
  Owner.owner (anomaDecode (Resource.data r));

type AuthMessage :=
  mkAuthMessage {
    consumed : Helper.Nullifier;
    mustBeCreated : Set Helper.Commitment
  };

mkAuthExtraDataMapEntry
  (self : PrivateKey)
  (created : List Resource)
  (consumed : Resource)
  : Pair Bytes32 Bytes :=
  let
    consumedNk : Helper.Nullifier := nullifier consumed self;
    createdCms : Set Helper.Commitment :=
      Data.Set.fromList (map commitment created);
    msg : AuthMessage :=
      mkAuthMessage@{
        consumed := consumedNk;
        mustBeCreated := createdCms
      };

    k := consumedNk;
    v := anomaEncode (msg, anomaSignDetached msg self);
  in k, v;

mkAuthExtraData
  (self : PrivateKey)
  (consumed : List Resource)
  (created : List Resource)
  : Map Bytes32 Bytes :=
  Data.Map.fromList
    (map (mkAuthExtraDataMapEntry self created) consumed);

isAuthorizedByOwner
  (self : Resource) (tx : Transaction) : Bool :=
  let
    owner : PublicKey := getOwner self;
    selfNk : Helper.Commitment := commitment self;
    lookupResult : Maybe (Pair AuthMessage Signature) :=
      lookupExtraData selfNk tx;
  in case lookupResult of
       | nothing := false
       | just (msg, sig) :=
         AuthMessage.consumed msg == selfNk
           && anomaVerifyDetached sig msg owner
           && isSubsetOfCreatedResources
             (AuthMessage.mustBeCreated msg)
             tx;
