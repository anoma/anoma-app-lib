module Intent.Swap.Resource;

import Stdlib.Prelude open;
import Stdlib.Trait.Ord.Eq open using {fromOrdToEq};

import Anoma.Resource open;
import Anoma.Identity open;
import Anoma.Utils open;
import AnomaHelpers open;

import Resource.Traits open;
import Intent.Asset open;
import Intent.Swap.Logic open;
import Randomness open;

module SwapIntent;
  type SwapIntent := mk@{resource : Resource};

  create (want : QuantifiedAssets) (receiver solver : ExternalIdentity) : SwapIntent :=
    mk
      mkResource@{
        logicRef := Ref.toRef (swapIntentLogic want receiver);
        labelRef := Ref.toRef (mkLabel 0);
        valueRef := Ref.toRef (mkValue 0);
        quantity := 1;
        ephemeral := true;
        nullifierKeyCommitment :=
          solver |> ExternalIdentity.unExternalIdentity |> mkNullifierKeyCommitment;
        nonce := mkNonce rand;
        randSeed := mkRandSeed rand
      };

  module SwapIntentInternal;
    --- Compares two ;SwapIntent; objects.
    compare (lhs rhs : SwapIntent) : Ordering :=
      Ord.cmp (SwapIntent.resource lhs) (SwapIntent.resource rhs);

    --- Implements the ;Ord; trait for ;SwapIntent;.
    instance
    SwapIntent-Ord : Ord SwapIntent := mkOrd compare;

    --- Implements the ;Eq; trait for ;SwapIntent;.
    instance
    SwapIntent-Eq : Eq SwapIntent := fromOrdToEq;
  end;

  open SwapIntent public;
end;

open SwapIntent using {SwapIntent} public;

instance
SwapIntent-Convertable : Convertable SwapIntent :=
  mkConvertable@{
    toResource (t : SwapIntent) : Resource := SwapIntent.resource t;
    fromResource (r : Resource) : SwapIntent := SwapIntent.mk r
  };

instance
SwapIntent-HasQuantity : HasQuantity SwapIntent := FromConvertable.hasQuantity {SwapIntent};

instance
SwapIntent-HasOwner : HasOwner SwapIntent := FromConvertable.hasOwner {SwapIntent};

instance
SwapIntent-HasEphemerality : HasEphemerality SwapIntent :=
  FromConvertable.hasEphemerality {SwapIntent};

instance
SwapIntent-HasKind : HasKind SwapIntent := FromConvertable.hasKind {SwapIntent};
