module Intent.Swap.Resource;

import Stdlib.Prelude open;
import Anoma.Resource open;
import Anoma.Identity open;
import Anoma.Utils open;
import AnomaHelpers open;

import Resource.Traits open;
import Intent.Asset open;
import Intent.Swap.Logic open;

module SwapIntent;
  type SwapIntent := mk {resource : Resource};

  create (want : QuantifiedAssets) (receiver solver : ExternalIdentity) : SwapIntent :=
    mk
      mkResource@{
        logicRef := Ref.toRef (swapIntentLogic want receiver);
        labelRef := Ref.toRef (mkLabel 0);
        valueRef := Ref.toRef (mkValue 0);
        quantity := 1;
        ephemeral := true;
        nullifierKeyCommitment :=
          solver |> ExternalIdentity.unExternalIdentity |> mkNullifierKeyCommitment;
        nonce := mkNonce rand;
        randSeed := mkRandSeed rand
      };

  open SwapIntent public;
end;

open SwapIntent using {SwapIntent} public;

instance
SwapIntent-Convertable : Convertable SwapIntent :=
  mkConvertable@{
    toResource (t : SwapIntent) : Resource := SwapIntent.resource t;
    fromResource (r : Resource) : SwapIntent := SwapIntent.mk r
  };

instance
SwapIntent-HasQuantity : HasQuantity SwapIntent := FromConvertable.hasQuantity {SwapIntent};

instance
SwapIntent-HasOwner : HasOwner SwapIntent := FromConvertable.hasOwner {SwapIntent};

instance
SwapIntent-HasEphemerality : HasEphemerality SwapIntent :=
  FromConvertable.hasEphemerality {SwapIntent};

instance
SwapIntent-HasKind : HasKind SwapIntent := FromConvertable.hasKind {SwapIntent};
