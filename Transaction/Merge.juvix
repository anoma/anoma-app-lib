module Transaction.Merge;

import Stdlib.Prelude open;
import Anoma.Resource open;
import Anoma.Identity open;
import Anoma.Transaction open;

import Resource.Error open;
import Resource.Traits open;
import Transaction.Traits open;

--- Merges ;Convertable; typed ;Resource;s of the same ;Kind;.
--- The function returns a ;StandardError; if the ;Convertable; ;Resource;s
--- - have different ;Kind;
--- - are ;Transferability.NonTransferable;
--- - are not owned by calling ;Identity;.
merge
  {R}
  {{Convertable R}}
  {{HasOwner R}}
  {{HasTransferability R}}
  {{HasQuantity R}}
  {{HasKind R}}
  {{TransactionConvertable R R}}
  (self : Identity)
  (toMerge : List R)
  (receiver : ExternalIdentity)
  : Result StandardError Transaction :=
  case toMerge of
    | nil :=
      throw
        mkInsufficientElementsError@{
          limit := 1;
          actual := 0
        }
    | t :: _ :=
      let
        myself : ExternalIdentity := Identity.external self;
        expectedKind : Kind := HasKind.get t;
        totalQuantity : Quantity := listFor (acc := 0) (ti in toMerge) {HasQuantity.get ti + acc};
        merged := HasOwner.set receiver (HasQuantity.set totalQuantity t);
      in case HasTransferability.get t of
           | NonTransferable := throw mkNonTransferableError
           | Transferable :=
             case find ((/=) expectedKind) (map HasKind.get toMerge) of
               | just otherKind :=
                 throw
                   mkInvalidKindError@{
                     expected := expectedKind;
                     actual := otherKind
                   }
               | nothing :=
                 case find ((/=) myself) (map (HasOwner.get) toMerge) of
                   | just notMyself :=
                     throw
                       mkUnauthorizedError@{
                         expected := myself;
                         actual := notMyself
                       }
                   | nothing := ok (TransactionConvertable.toTransaction self toMerge [merged]);
