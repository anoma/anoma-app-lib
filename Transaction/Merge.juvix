module Transaction.Merge;

import Stdlib.Prelude open;
import Data.Set as Set open using {Set};

import Anoma.Resource open;
import Anoma.Identity open;
import Anoma.Transaction open;

import Resource.Error open;
import Resource.Traits open;
import Transaction.Traits open;
import AnomaHelpers open;

--- Merges ;Convertable; typed ;Resource;s of the same ;Kind;.
--- The function returns a ;StandardError; if the ;Convertable; ;Resource;s
--- - have different ;Kind;
--- - are ;Transferability.NonTransferable;
--- - are not owned by calling ;Identity;.
merge
  {R}
  {{Ord R}}
  {{Convertable R}}
  {{HasOwner R}}
  {{HasTransferability R}}
  {{HasQuantity R}}
  {{HasKind R}}
  {{ActionConvertable R R}}
  (standardInputs : StandardInputs)
  (toMerge : List R)
  (receiver : ExternalIdentity)
  : Result StandardError Transaction :=
  case toMerge of
    | nil :=
      throw
        mkInsufficientElementsError@{
          limit := 1;
          actual := 0
        }
    | t :: _ :=
      let
        self : ExternalIdentity := standardInputs |> StandardInputs.identity |> Identity.external;
        expectedKind : Kind := HasKind.get t;
        totalQuantity : Quantity := listFor (acc := 0) (ti in toMerge) {HasQuantity.get ti + acc};
        merged := HasOwner.set receiver (HasQuantity.set totalQuantity t);
      in case HasTransferability.get t of
           | NonTransferable := throw mkNonTransferableError
           | Transferable :=
             case find ((/=) expectedKind) (map HasKind.get toMerge) of
               | just otherKind :=
                 throw
                   mkInvalidKindError@{
                     expected := expectedKind;
                     actual := otherKind
                   }
               | nothing :=
                 case find ((/=) self) (map (HasOwner.get) toMerge) of
                   | just notMyself :=
                     throw
                       mkUnauthorizedError@{
                         expected := self;
                         actual := notMyself
                       }
                   | nothing :=
                     ok
                       mkTransactionHelper@{
                         roots := Set.singleton (StandardInputs.currentRoot standardInputs);
                         actions :=
                           Set.singleton
                             (ActionConvertable.toAction
                               standardInputs
                               (Set.fromList toMerge)
                               (Set.singleton merged))
                       };
