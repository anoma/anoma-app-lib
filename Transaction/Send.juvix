module Transaction.Send;

import Stdlib.Prelude open;
import Stdlib.Data.Nat.Ord open using {compare};
import Anoma.Resource open;
import Anoma.Identity open;
import Anoma.Transaction open;

import Resource.Error open;
import Resource.Traits open;
import Transaction.Traits open;
import Transaction.Transfer open;
import Transaction.Split open;

--- Sends a ;HasQuantity; of token ;Resource; to a receiver, if the calling ;Identity; is the owner.
--- If the quantity is lower than of the quantity of the consumed ;Resource;, the function creates
--- a second ;Resource; with the difference being owned by the caller.
--- The function returns a ;StandardError; if
--- - the quantity exceeds the quantity of the resource
--- - the ;transfer; or ;split; functions return a ;StandardError;.
send
  {R}
  {{Convertable R}}
  {{HasOwner R}}
  {{HasQuantity R}}
  {{HasTransferability R}}
  {{TransactionConvertable R R}}
  (self : Identity)
  (toSend : R)
  (quantity : Quantity)
  (receiver : ExternalIdentity)
  : Result StandardError Transaction :=
  let
    myself : ExternalIdentity := Identity.external self;
    balance : Quantity := HasQuantity.get toSend;
  in case QuantityInternal.compare balance quantity of
       | LT :=
         throw
           mkInsufficientHasQuantityError@{
             limit := balance;
             actual := quantity
           }
       | EQ := transfer self toSend receiver
       | GT :=
         let
           difference : Quantity :=
             intSubNat (Quantity.unQuantity balance) (Quantity.unQuantity quantity)
               |> toNat
               |> mkQuantity;
         in split self toSend [quantity, receiver; difference, myself];
