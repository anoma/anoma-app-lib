module Applib.Resource.Traits.Owner;

import Stdlib.Prelude open;
import Stdlib.Data.Map as Map open using {Map; empty; insert};

import Anoma.Resource open;
import Anoma.Identity.External open;
import Anoma.Builtin.System open;

import Applib.Authorization.Identities open;

trait
type HasOwner ResourceT :=
  mkHasOwner@{
    get : ResourceT -> ExternalIdentity;
    set : ExternalIdentity -> ResourceT -> ResourceT
  };

--- The expected position of ownership information in the ;Value; map.
ownershipStandardMapKey : Nat := anomaEncode "Owner";

instance
Resource-HasOwner : HasOwner Resource :=
  mkHasOwner@{
    get (resource : Resource) : ExternalIdentity :=
      let
        valueMap : Map Nat Nat :=
          resource |> Resource.valueRef |> Reference.from |> Value.unValue |> anomaDecode;
      in case Map.lookup ownershipStandardMapKey valueMap of
           | just value := anomaDecode value
           | nothing := Zero.externalIdentity;

    set (owner : ExternalIdentity) (resource : Resource) : Resource :=
      let
        oldValueMap : Map Nat Nat :=
          resource |> Resource.valueRef |> Reference.from |> Value.unValue |> anomaDecode;
        value := anomaEncode owner;
        newValueMap := Map.insert ownershipStandardMapKey value oldValueMap;
      in resource@Resource{valueRef := newValueMap |> anomaEncode |> mkValue |> Reference.to}
  };
