module Applib.Utils.Dummy.Transaction.Initialize;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open;
import Stdlib.Data.Set as Set open using {Set};

import Anoma.Resource open;
import Anoma.Transaction open;
import Anoma.Identity open;

import Applib.Authorization.Identities open;
import Applib.Utils.Dummy.Resource open;
import Applib.Resource.Error open;
import Applib.Helpers open;

-- TODO Use generic initialize.
initialize (standardInputs : StandardInputs) (dummy : Resource) : Transaction :=
  let
    expectedKind :=
      KindInternal.kind@{
        logicRef := Reference.to alwaysValidLogic;
        labelRef := Reference.to emptyLabel
      };
    currentKind :=
      kind@{
        resource := dummy
      };
  in "DEBUG: Evaluating `Applib.Utils.Dummy.Transaction.initialize`"
    >-> fromResult
      case currentKind == expectedKind of {
        | false :=
          throw
            mkInvalidKindError@{
              expected := expectedKind;
              actual := currentKind
            }
        | true :=
          ok
            mkTransactionHelper@{
              roots := Set.singleton (StandardInputs.currentRoot standardInputs);
              actions :=
                Set.singleton
                  mkActionHelper@{
                    identity := StandardInputs.identity standardInputs;
                    consumed :=
                      Set.singleton
                        dummy@Resource{
                          ephemeral := true;
                          nullifierKeyCommitment := standardInputs
                            |> StandardInputs.identity
                            |> toNullifierKeyCommitment
                        };
                    created := Set.singleton dummy;
                    appData := Set.empty;
                    customInputs := Set.empty
                  }
            }
      };
