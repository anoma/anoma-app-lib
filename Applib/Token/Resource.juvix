module Applib.Token.Resource;

import Stdlib.Prelude open;
import Stdlib.Trait.Ord.Eq open using {fromOrdToEq};

import Anoma.Resource open;
import Anoma.Identity open;
import Applib.Helpers open;

import Applib.Resource.Traits open;
import Applib.Token.Label open;
import Applib.Token.Logic open;
import Anoma.Builtin.System open;
import Anoma.Utils open;

import Applib.Authorization.Identities open;
import Applib.Random open;

module Token;
  type Token := mk@{resource : Resource};

  create
    (quantity : Quantity)
    (tokenLabel : TokenLabel)
    (owner : ExternalIdentity)
    {ephemeral : Bool := false}
    : Token :=
    mk
      mkResource@{
        logicRef :=
          Reference.to
            (tokenLogic (TokenLabel.supply tokenLabel) (TokenLabel.originator tokenLabel));
        labelRef := Reference.to (tokenLabel |> anomaEncode |> mkLabel);
        valueRef := Reference.to (owner |> anomaEncode |> mkValue);
        quantity;
        ephemeral;
        nullifierKeyCommitment := ExternalIdentity.toNullifierKeyCommitment owner;
        nonce := mkNonce rand;
        randSeed := mkRandSeed rand
      };

  module TokenInternal;
    --- Compares two ;Token; objects.
    compare (lhs rhs : Token) : Ordering := Ord.cmp (Token.resource lhs) (Token.resource rhs);

    --- Implements the ;Ord; trait for ;Token;.
    instance
    Token-Ord : Ord Token := mkOrd compare;

    --- Implements the ;Eq; trait for ;Token;.
    instance
    Token-Eq : Eq Token := fromOrdToEq;
  end;

  open Token public;
end;

open Token using {Token} public;

instance
Token-Convertable : Convertable Token :=
  mkConvertable@{
    toResource (token : Token) : Resource := Token.resource token;
    fromResource (resource : Resource) : Token :=
      Token.mk@{
        resource
      }
  };

-- TODO Refactor
kindFromTokenLabel (tokenLabel : TokenLabel) : Kind :=
  KindInternal.kind@{
    logicRef :=
      Reference.to (tokenLogic (TokenLabel.supply tokenLabel) (TokenLabel.originator tokenLabel));
    labelRef := toLabelRef tokenLabel
  };

instance
Token-HasQuantity : HasQuantity Token := FromConvertable.hasQuantity {Token};

instance
Token-HasOwner : HasOwner Token :=
  mkHasOwner@{
    get (token : Token) : ExternalIdentity :=
      token
        |> Convertable.toResource
        |> Resource.valueRef
        |> Reference.from
        |> Value.unValue
        |> anomaDecode;
    set (owner : ExternalIdentity) (token : Token) : Token :=
      (token |> Convertable.toResource)@Resource{valueRef := owner
          |> anomaEncode
          |> mkValue
          |> Reference.to}
        |> Convertable.fromResource
  };

instance
Token-HasEphemerality : HasEphemerality Token := FromConvertable.hasEphemerality {Token};

instance
Token-HasLogic : HasLogic Token := FromConvertable.hasLogic {Token};

instance
Token-HasKind : HasKind Token := FromConvertable.hasKind {Token};

instance
Token-Label-HasLabel : HasLabel Token TokenLabel :=
  mkHasLabel@{
    get (token : Token) : TokenLabel :=
      token |> Convertable.toResource |> Resource.labelRef |> fromLabelRef;
    set (tokenLabel : TokenLabel) (token : Token) : Token :=
      (token |> Convertable.toResource)@Resource{labelRef := toLabelRef tokenLabel}
        |> Convertable.fromResource
  };

instance
Token-HasSupply : HasSupply Token :=
  mkHasSupply@{
    get (token : Token) : Supply := token |> HasLabel.get |> TokenLabel.supply;
    set (supply : Supply) (token : Token) : Token :=
      let
        newLabel := (HasLabel.get token)@TokenLabel{supply := supply};
      in HasLabel.set newLabel token
  };

instance
Token-HasTransferability : HasTransferability Token :=
  mkHasTransferability@{
    get (token : Token) : Transferability := token |> HasLabel.get |> TokenLabel.transferability;
    set (transferability : Transferability) (token : Token) : Token :=
      let
        newLabel := (HasLabel.get token)@TokenLabel{transferability := transferability};
      in HasLabel.set newLabel token
  };

instance
Token-HasOriginator : HasOriginator Token :=
  mkHasOriginator@{
    get (token : Token) : ExternalIdentity := token |> HasLabel.get |> TokenLabel.originator;
    set (originator : ExternalIdentity) (token : Token) : Token :=
      let
        newLabel := (HasLabel.get token)@TokenLabel{originator := originator};
      in HasLabel.set newLabel token
  };
