module Applib.Transaction.Initialize;

import Stdlib.Prelude open;
import Anoma.Resource open;
import Anoma.Transaction open;
import Anoma.Identity open;

import Applib.Helpers open;
import Applib.Resource.Error open;
import Applib.Resource.Traits open;
import Applib.Transaction.Traits open;
import Applib.Utils.Dummy.Transaction as Dummy open using {finalize};
import Applib.Authorization.Identities open;

--- Initializes a ;Convertable; typed ;Resource;.
--- For tokens with fixed supply, a dummy is required.
--- The function returns a ;StandardError; if
--- - a dummy is provided for tokens with ;Unbound; supply.
--- - no dummy is provided for tokens with ;Fixed; supply.
--- - the supply type is ;Capped; which is not supported.
initialize
  {R}
  {{Ord R}}
  {{Convertable R}}
  {{HasOwner R}}
  {{HasSupply R}}
  {{HasEphemerality R}}
  {{ActionConvertable R R}}
  (standardInputs : StandardInputs)
  (toInitialize : R)
  (maybeDummy : Maybe Resource)
  : Result StandardError Transaction :=
  let
    self : ExternalIdentity := standardInputs |> StandardInputs.identity |> Identity.external;
    ephResource : R := HasEphemerality.set Ephemerality.Ephemeral (HasOwner.set self toInitialize);
    tx : Transaction :=
      mkTransactionHelper@{
        roots := Set.singleton (StandardInputs.currentRoot standardInputs);
        actions :=
          Set.singleton
            (ActionConvertable.toAction
              standardInputs
              (Set.singleton ephResource)
              (Set.singleton toInitialize))
      };
  in case HasSupply.get toInitialize of
       | Unbound :=
         case maybeDummy of {
           | nothing := ok tx
           | just dummy :=
             throw
               mkDefaultError@{
                 msg := "A dummy resource is only required for resources with fixed supply."
               }
         }
       | Capped :=
         throw
           mkDefaultError@{
             msg := "Tokens with capped supply are not supported yet."
           }
       | Fixed expectedNullifier :=
         case maybeDummy of
           | nothing :=
             throw
               mkDefaultError@{
                 msg :=
                   "A resource to consume must be provided whose nullifier is referenced in the fixed supply type."
               }
           | just dummy :=
             let
               actualNullifier :=
                 nullifier@{
                   resource := dummy;
                   nullifierKey := standardInputs |> StandardInputs.identity |> toNullifierKey
                 };
             in case actualNullifier == expectedNullifier of
                  | false :=
                    throw
                      mkDefaultError@{
                        msg :=
                          "The provided resource's nullifier does not match the one referenced in the fixed supply type."
                      }
                  | true :=
                    ok
                      composeTransactions@{
                        tx1 := tx;
                        tx2 :=
                          Dummy.finalize@{
                            standardInputs;
                            dummy
                          }
                      };
