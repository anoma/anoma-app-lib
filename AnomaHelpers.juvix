module AnomaHelpers;

import Stdlib.Prelude open;
import Anoma open;

import Data.Set open;
import Data.Map open;

-- Should be added to the `juvix-stdlib`
type Either Error Result :=
  | left Error
  | right Result;

-- Should be added to the `juvix-anoma-stdlib`
type Bytes32 := mkBytes32 {unBytes32 : Nat};

instance
Bytes32Ord : Ord Bytes32 :=
  mkOrd@{
    cmp : Bytes32 -> Bytes32 -> Ordering
      | (mkBytes32 b1) (mkBytes32 b2) := Ord.cmp b1 b2
  };

natToBytes32 : Nat -> Bytes32 := mkBytes32;

type Bytes := mkBytes {unBytes : Nat};

instance
BytesOrd : Ord Bytes :=
  mkOrd@{
    cmp : Bytes -> Bytes -> Ordering
      | (mkBytes b1) (mkBytes b2) := Ord.cmp b1 b2
  };

natToBytes : Nat -> Bytes := mkBytes;

getLogic (r : Resource) : Nat :=
  anomaEncode (Resource.logic r);

type Error := mkError {msg : String};

type InsufficientElementsError :=
  mkInsufficientElementsError {
    limit : Nat;
    actual : Nat
  };

instance
InsufficientElementsError-Show
  : Show InsufficientElementsError :=
  mkShow
    λ {e :=
      "InsufficientElementsError:\n{"
        ++str "limit : "
        ++str (e |> InsufficientElementsError.limit |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> InsufficientElementsError.actual |> Show.show)
        ++str "}"};

type InsufficientQuantityError :=
  mkInsufficientQuantityError {
    limit : Nat;
    actual : Nat
  };

instance
InsufficientQuantityError-Show
  : Show InsufficientQuantityError :=
  mkShow
    λ {e :=
      "InsufficientQuantityError:\n{"
        ++str "limit : "
        ++str (e |> InsufficientQuantityError.limit |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> InsufficientQuantityError.actual |> Show.show)
        ++str "}"};

type InvalidLogicError :=
  mkInvalidLogicError {
    expected : Nat;
    actual : Nat
  };

instance
InvalidLogicError-Show : Show InvalidLogicError :=
  mkShow
    λ {e :=
      "InvalidLogicError:\n{"
        ++str "expected : "
        ++str (e |> InvalidLogicError.expected |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> InvalidLogicError.actual |> Show.show)
        ++str "}"};

isCreated (r : Resource) (tx : Transaction) : Bool :=
  elem
    (==)
    r
    (ResourcePartition.created (partitionResources tx));

isConsumed (r : Resource) (tx : Transaction) : Bool :=
  elem
    (==)
    r
    (ResourcePartition.consumed (partitionResources tx));

isPresent
  (cms : List Helper.Commitment)
  (cm : Helper.Commitment)
  : Bool := elem (==) cm cms;

isSublist (sub sup : List Helper.Commitment) : Bool :=
  all (isPresent sup) sub;

findMismatch {A} {{Eq A}} (ref : A) : List A -> Maybe A
  | nil := nothing
  | (x :: xs) :=
    if
      | x /= ref := just x
      | else := findMismatch ref xs;

isSubset {A} {{Ord A}} (sub sup : Set A) : Bool :=
  all (x in Data.Set.toList sub)
    member? x sup;

isSubsetOfCreatedResources
  (sub : Set Helper.Commitment) (tx : Transaction) : Bool :=
  let
    sup : Set Helper.Commitment :=
      Data.Set.fromList
        (map
          commitment
          (ResourcePartition.created (partitionResources tx)));
  in isSubset sub sup;

lookupExtraData
  {Value : Type}
  (key : Bytes32)
  (tx : Transaction)
  : Maybe Value :=
  let
    keyValueMap : Map Bytes32 Value :=
      anomaDecode (Transaction.extra tx);
  in lookup key keyValueMap;

mkTransaction
  (self : PrivateKey)
  (consumed : List Resource)
  (created : List Resource)
  (extraData : Map Bytes32 Bytes)
  : Transaction :=
  Transaction.mk@{
    roots := [];
    commitments := map commitment created;
    nullifiers := map (r in consumed) nullifier r self;
    proofs := consumed ++ created;
    delta := [];
    extra := anomaEncode (extraData);
    preference := 0
  };
