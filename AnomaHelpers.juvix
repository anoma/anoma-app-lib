module AnomaHelpers;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open using {failwith};
import Stdlib.Trait.Ord.Eq open using {fromOrdToEq};

import Authorization.Identities open;
import Data.Set as Set open using {Set};
import Data.Map as Map open using {Map};
import Anoma.Identity open;
import Anoma.Resource as Resource open;
import Anoma.Transaction as Transaction open;
--import Anoma.Transaction.Object as Transaction open using {commitmentSet; nullifierSet};
import Anoma.Builtin.System open;
import Anoma.Proving.Types open;

{-
-- TODO Replace by ByteArray / List Byte and delete
type Bytes32 := mkBytes32 {unBytes32 : Nat};

instance
Bytes32-Ord : Ord Bytes32 :=
  mkOrd@{
    cmp : Bytes32 -> Bytes32 -> Ordering
      | (mkBytes32 b1) (mkBytes32 b2) := Ord.cmp b1 b2
  };

instance
Bytes32-Eq : Eq Bytes32 := Stdlib.Trait.Ord.Eq.fromOrdToEq;

instance
Bytes32-Show : Show Bytes32 := mkShow \ {b := natToString (Bytes32.unBytes32 b)};

natToBytes32 : Nat -> Bytes32 := mkBytes32;

type Bytes := mkBytes {unBytes : Nat};

instance
Bytes-Ord : Ord Bytes :=
  mkOrd@{
    cmp : Bytes -> Bytes -> Ordering
      | (mkBytes b1) (mkBytes b2) := Ord.cmp b1 b2
  };

natToBytes : Nat -> Bytes := mkBytes;
-}

-- TODO Refactor
instance
ExternalIdentity-Show : Show ExternalIdentity :=
  failwith "`ExternalIdentity-Show : Show ExternalIdentity` NOT IMPLEMENTED";
--mkShow \ {e := natToString (ExternalIdentity.unExternalIdentity e)};

-- TODO Refactor
instance
InternalIdentity-Show : Show InternalIdentity :=
  failwith "`InternalIdentity-Show : Show InternalIdentity` NOT IMPLEMENTED";
--mkShow \ {e := natToString (InternalIdentity.unInternalIdentity e)};

findCreatedResource (commitment : Commitment) (resources : Set Resource) : Maybe Resource :=
  find \ {r := Resource.commitment r == commitment} (Set.toList resources);

-- TODO where to get the nullifierKey from. Probably customInputs
findConsumedResource
  (nullifier : Nullifier)
  (nullifierKey : NullifierKey)
  (resources : Set Resource)
  : Maybe Resource :=
  find \ {r := Resource.nullifier r nullifierKey == nullifier} (Set.toList resources);

-- TODO Refactor
isCreated (commitment : Commitment) (publicInputs : ResourceLogic.Instance) : Bool :=
  Set.member? commitment (ResourceLogic.Instance.commitments publicInputs);

-- TODO Refactor
isConsumed (nullifier : Nullifier) (publicInputs : ResourceLogic.Instance) : Bool :=
  Set.member? nullifier (ResourceLogic.Instance.nullifiers publicInputs);

-- TODO Refactor.
--lifecycle (r : Resource) (tx : Transaction) : Lifecycle :=
--  failwith "`lifecycle (r : Resource) (tx : Transaction) : Lifecycle ` NOT IMPLEMENTED";

{-
  let
    rs := partitionResources tx;
    consumed := ResourcePartition.consumed rs;
    created := ResourcePartition.created rs;
  in if
    | elem (==) r consumed := Consumed
    | elem (==) r created := Created
    | else := Unknown;
-}

-- TODO refactor error handling.
-- TODO within action or
isNullifierPresent
  (nullifier : Resource.Nullifier) (nullifierSet : Set Resource.Nullifier) : Bool :=
  Set.member? nullifier nullifierSet;

isSubset {A} {{Ord A}} (sub sup : Set A) : Bool := all (x in Set.toList sub) Set.member? x sup;

isSublist {A} {{Ord A}} (sub sup : List A) : Bool :=
  let
    sup' := Set.fromList sup;
  in all (x in sub)
       Set.member? x sup';

module AppDataMap;
  fromSet (appDataSet : Set AppDataEntry) : Map AppDataKey AppDataValue :=
    Map.fromList
      (map (entry in Set.toList appDataSet) {AppDataEntry.key entry, AppDataEntry.value entry});

  toSet (appDataMap : Map AppDataKey AppDataValue) : Set AppDataEntry :=
    Set.fromList
      (map (key, value in Map.toList appDataMap)
        {mkAppDataEntry@{
          key;
          value
        }});
end;

lookupAppData {Key Value : Type} (key : Key) (appData : AppData) : Maybe Value :=
  let
    appDataAsMap : Map AppDataKey AppDataValue := AppDataMap.fromSet appData;
  in map
    (AppDataValue.unAppDataValue >> anomaDecode)
    (Map.lookup (anomaEncode key |> mkAppDataKey) appDataAsMap);

-- TODO refactor
lookupCustomInputs
  {Key Value : Type} (key : Key) (customInputs : ResourceLogic.CustomInputs) : Maybe Value :=
  lookupAppData@{
    key;
    appData := customInputs
  };

{-
lookupExtraData {Key Value : Type} (key : Key) (tx : Transaction) : Maybe Value :=
  let
    keyValueMap : Map Bytes32 Bytes := anomaDecode (Transaction.extra tx);
  in map (Bytes.unBytes >> anomaDecode) (Map.lookup (anomaEncode key |> natToBytes32) keyValueMap);

mkExtraDataEntry {Key Value : Type} : Pair Key Value -> Pair Bytes32 Bytes
  | (key, value) := natToBytes32 (anomaEncode key), natToBytes (anomaEncode value);

computeDelta (consumed : List Resource) (created : List Resource) : Delta :=
  let
    withCreatedDelta : DeltaMap := for (acc := emptyDeltaMap) (r in created) addDelta acc r;
    withConsumedDelta : DeltaMap := for (acc := withCreatedDelta) (r in consumed) subDelta acc r;
  in toDelta withConsumedDelta;
-}

--- TODO Refactor to use actions
mkTransactionHelper
  (identity : Identity)
  (consumed : List Resource)
  (created : List Resource)
  (extraData : AppData)
  --Map Bytes32 Bytes)
  : Transaction := failwith "`mkTransactionHelper` NOT IMPLEMENTED";

{-
  Transaction.mk@{
    roots := [];
    commitments := map commitment created;
    nullifiers := map (r in consumed) nullifier r nullifierKey;
    proofs := consumed ++ created;
    delta :=
      computeDelta@{
        consumed;
        created
      };
    extra := anomaEncode (extraData);
    preference := 0
  };
  -}
emptyTx : Transaction :=
  mkTransactionHelper@{
    identity := Universal.identity;
    consumed := [];
    created := [];
    extraData := Set.empty
  };

composeAll (txs : List Transaction) : Transaction :=
  for (acc := emptyTx) (tx in txs) {composeTransactions acc tx};

rand : Nat := 0;
