module AnomaHelpers;

import Stdlib.Prelude open;
import Stdlib.Trait.Ord.Eq open using {fromOrdToEq};

import Anoma open;

import Data.Set open;
import Data.Map open;

-- Should be added to the `juvix-stdlib`
type Either Error Result :=
  | left Error
  | right Result;

--- Returns the leftmost element of the list satisfying the predicate or
--- nothing if there's no such element.
find {A} (predicate : A → Bool) : List A → Maybe A
  | nil := nothing
  | (x :: xs) :=
    if
      | predicate x := just x
      | else := find predicate xs;

-- Should be added to the `juvix-anoma-stdlib`
type Bytes32 := mkBytes32 {unBytes32 : Nat};

instance
Bytes32-Ord : Ord Bytes32 :=
  mkOrd@{
    cmp : Bytes32 -> Bytes32 -> Ordering
      | (mkBytes32 b1) (mkBytes32 b2) := Ord.cmp b1 b2
  };

instance
Bytes32-Eq : Eq Bytes32 := Stdlib.Trait.Ord.Eq.fromOrdToEq;

instance
Bytes32-Show : Show Bytes32 :=
  mkShow \ {b := natToString (Bytes32.unBytes32 b)};

natToBytes32 : Nat -> Bytes32 := mkBytes32;

type Bytes := mkBytes {unBytes : Nat};

instance
Bytes-Ord : Ord Bytes :=
  mkOrd@{
    cmp : Bytes -> Bytes -> Ordering
      | (mkBytes b1) (mkBytes b2) := Ord.cmp b1 b2
  };

natToBytes : Nat -> Bytes := mkBytes;

getLogic (r : Resource) : Nat :=
  anomaEncode (Resource.logic r);

type Error := mkError {msg : String};

type InsufficientElementsError :=
  mkInsufficientElementsError {
    limit : Nat;
    actual : Nat
  };

instance
InsufficientElementsError-Show
  : Show InsufficientElementsError :=
  mkShow
    \ {e :=
      "InsufficientElementsError:\n{"
        ++str "limit : "
        ++str (e |> InsufficientElementsError.limit |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> InsufficientElementsError.actual |> Show.show)
        ++str "}"};

type InsufficientQuantityError :=
  mkInsufficientQuantityError {
    limit : Nat;
    actual : Nat
  };

instance
InsufficientQuantityError-Show
  : Show InsufficientQuantityError :=
  mkShow
    \ {e :=
      "InsufficientQuantityError:\n{"
        ++str "limit : "
        ++str (e |> InsufficientQuantityError.limit |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> InsufficientQuantityError.actual |> Show.show)
        ++str "}"};

type InvalidLogicError :=
  mkInvalidLogicError {
    expected : Nat;
    actual : Nat
  };

instance
InvalidLogicError-Show : Show InvalidLogicError :=
  mkShow
    \ {e :=
      "InvalidLogicError:\n{"
        ++str "expected : "
        ++str (e |> InvalidLogicError.expected |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> InvalidLogicError.actual |> Show.show)
        ++str "}"};

isCreated (r : Resource) (tx : Transaction) : Bool :=
  elem
    (==)
    r
    (ResourcePartition.created (partitionResources tx));

isConsumed (r : Resource) (tx : Transaction) : Bool :=
  elem
    (==)
    r
    (ResourcePartition.consumed (partitionResources tx));

isPresent (r : Resource) (tx : Transaction) : Bool :=
  let
    rs := partitionResources tx;
    consumed := ResourcePartition.consumed rs;
    created := ResourcePartition.created rs;
  in elem (==) r (consumed ++ created);

type Lifecycle :=
  | Consumed
  | Created
  | Unknown;

lifecycle (r : Resource) (tx : Transaction) : Lifecycle :=
  let
    rs := partitionResources tx;
    consumed := ResourcePartition.consumed rs;
    created := ResourcePartition.created rs;
  in if
    | elem (==) r consumed := Consumed
    | elem (==) r created := Created
    | else := Unknown;

isEphemeral (r : Resource) : Bool := Resource.eph r;

type Ephemerality :=
  | NonEphemeral
  | Ephemeral;

ephemerality (r : Resource) : Ephemerality :=
  if
    | isEphemeral r := Ephemeral
    | else := NonEphemeral;

isNullifierPresent
  (nf : Helper.Nullifier) (tx : Transaction) : Bool :=
  elem (==) nf (Transaction.nullifiers tx);

isSubset {A} {{Ord A}} (sub sup : Set A) : Bool :=
  all (x in Data.Set.toList sub)
    member? x sup;

isSublist {A} {{Ord A}} (sub sup : List A) : Bool :=
  all (x in sub)
    member? x (Data.Set.fromList sup);

commitmentSet (tx : Transaction) : Set Helper.Commitment :=
  Data.Set.fromList (Transaction.commitments tx);

nullifierSet (tx : Transaction) : Set Helper.Nullifier :=
  Data.Set.fromList (Transaction.nullifiers tx);

lookupExtraData
  {Value : Type}
  (key : Bytes32)
  (tx : Transaction)
  : Maybe Value :=
  let
    keyValueMap : Map Bytes32 Value :=
      anomaDecode (Transaction.extra tx);
  in lookup key keyValueMap;

mkTransaction
  (nullifierKey : PrivateKey)
  (consumed : List Resource)
  (created : List Resource)
  (extraData : Map Bytes32 Bytes)
  : Transaction :=
  Transaction.mk@{
    roots := [];
    commitments := map commitment created;
    nullifiers := map (r in consumed) nullifier r nullifierKey;
    proofs := consumed ++ created;
    delta := [];
    extra := anomaEncode (extraData);
    preference := 0
  };

composeTransactions (tx1 tx2 : Transaction) : Transaction :=
  Transaction.mk@{
    roots := Transaction.roots tx1 ++ Transaction.roots tx2;
    commitments :=
      Transaction.commitments tx1
        ++ Transaction.commitments tx2;
    nullifiers :=
      Transaction.nullifiers tx1 ++ Transaction.nullifiers tx2;
    proofs := Transaction.proofs tx1 ++ Transaction.proofs tx2;
    delta := Transaction.delta tx1 ++ Transaction.delta tx2;
    extra :=
      let
        kvList1 : List (Pair Bytes32 Bytes) :=
          Data.Map.toList (anomaDecode (Transaction.extra tx1));
        kvList2 : List (Pair Bytes32 Bytes) :=
          Data.Map.toList (anomaDecode (Transaction.extra tx2));
      in anomaEncode (Data.Map.fromList (kvList1 ++ kvList2));

    preference := 0
  };
