module AnomaHelpers;

import Stdlib.Prelude open;
import Stdlib.Debug.Fail open using {failwith};
import Stdlib.Trait.Ord.Eq open using {fromOrdToEq};

import Authorization.Identities open;
import Data.Set as Set open using {Set};
import Data.Map as Map open using {Map};
import Anoma.Identity open;
import Anoma.Resource as Resource open;
import Anoma.Transaction as Transaction open;
import Anoma.State.CommitmentTree as CommitmentTree open;
import Anoma.Proving.DeltaProof as DeltaProof open;
import Anoma.Proving.ComplianceProof as ComplianceProof open;
import Anoma.Proving.ResourceLogicProof as ResourceLogicProof open;
import Anoma.Utils open;

import Anoma.Delta as Delta open;
import Anoma.Builtin.System open;
import Anoma.Builtin.ByteArray open;
import Anoma.Proving.Types open;

import Resource.Traits.Convertable open;

instance
ExternalIdentity-Show : Show ExternalIdentity :=
  mkShow \ {id := id |> ExternalIdentity.unExternalIdentity |> toAnomaContents |> natToString};

instance
InternalIdentity-Show : Show InternalIdentity :=
  mkShow \ {id := id |> InternalIdentity.unInternalIdentity |> toAnomaContents |> natToString};

instance
Identity-Show : Show Identity :=
  mkShow
    \ {id :=
      "{"
        ++str "external : "
        ++str (id |> Identity.external |> Show.show)
        ++str ", "
        ++str "internal : "
        ++str (id |> Identity.internal |> Show.show)
        ++str "}"};

findCreatedResource (commitment : Commitment) (resources : Set Resource) : Maybe Resource :=
  find \ {resource := Resource.commitment resource == commitment} (Set.toList resources);

-- TODO where to get the nullifierKey from. Probably customInputs
findConsumedResource
  (nullifier : Nullifier)
  (nullifierKey : NullifierKey)
  (resources : Set Resource)
  : Maybe Resource :=
  find \ {resource := Resource.nullifier nullifierKey resource == nullifier} (Set.toList resources);

-- TODO Refactor
isCreated (commitment : Commitment) (publicInputs : ResourceLogic.Instance) : Bool :=
  Set.member? commitment (ResourceLogic.Instance.commitments publicInputs);

-- TODO Refactor
isConsumed (nullifier : Nullifier) (publicInputs : ResourceLogic.Instance) : Bool :=
  Set.member? nullifier (ResourceLogic.Instance.nullifiers publicInputs);

-- TODO Refactor.
{-
lifecycle (r : Resource) (tx : Transaction) : Lifecycle :=
  let
    rs := partitionResources tx;
    consumed := ResourcePartition.consumed rs;
    created := ResourcePartition.created rs;
  in if
    | elem (==) r consumed := Consumed
    | elem (==) r created := Created
    | else := Unknown;
-}

-- TODO refactor error handling.
-- TODO within action or
isNullifierPresent
  (nullifier : Resource.Nullifier) (nullifierSet : Set Resource.Nullifier) : Bool :=
  Set.member? nullifier nullifierSet;

isSubset {A} {{Ord A}} (sub sup : Set A) : Bool := all (x in Set.toList sub) Set.member? x sup;

isSublist {A} {{Ord A}} (sub sup : List A) : Bool :=
  let
    sup' := Set.fromList sup;
  in all (x in sub)
       Set.member? x sup';

module AppDataMap;
  fromSet (appDataSet : Set AppDataEntry) : Map AppDataKey AppDataValue :=
    Map.fromList
      (map (entry in Set.toList appDataSet) {AppDataEntry.key entry, AppDataEntry.value entry});

  toSet (appDataMap : Map AppDataKey AppDataValue) : Set AppDataEntry :=
    Set.fromList
      (map (key, value in Map.toList appDataMap)
        {mkAppDataEntry@{
          key;
          value
        }});
end;

lookupAppData {Key Value : Type} (key : Key) (appData : AppData) : Maybe Value :=
  let
    appDataAsMap : Map AppDataKey AppDataValue := AppDataMap.fromSet appData;
  in map
    (AppDataValue.unAppDataValue >> anomaDecode)
    (Map.lookup (anomaEncode key |> mkAppDataKey) appDataAsMap);

-- TODO refactor
lookupCustomInputs
  {Key Value : Type} (key : Key) (customInputs : ResourceLogic.CustomInputs) : Maybe Value :=
  lookupAppData@{
    key;
    appData := customInputs
  };

type StandardInputs :=
  mkStandardInputs {
    identity : Identity;
    currentRoot : CommitmentTree.Root
  };

alwaysTrueLogic
  (publicInputs : ResourceLogic.Instance) (privateInputs : ResourceLogic.Witness) : Bool := true;

emptyResource : Resource :=
  mkResource@{
    logicRef := Ref.toRef alwaysTrueLogic;
    labelRef := Ref.toRef (mkLabel 0);
    valueRef := Ref.toRef (mkValue 0);
    quantity := 0;
    ephemeral := true;
    nullifierKeyCommitment := Universal.nullifierKeyCommitment;
    nonce := mkNonce rand;
    randSeed := mkRandSeed rand
  };

emptyDeltaProof : DeltaProof.ProofRecord :=
  let
    verifyingKey := Delta.mkVerifyingKey unit;
    provingKey := Delta.mkProvingKey unit;
    instance' := Delta.mkInstance unit;
    witness := Delta.mkWitness unit;
    proof := DeltaProof.prove provingKey instance' witness;
  in verifyingKey, proof, witness;

emptyResourceLogicProof : ResourceLogicProof.ProofRecord :=
  let
    verifyingKey := ResourceLogic.mkVerifyingKey unit;
    provingKey := ResourceLogic.mkProvingKey emptyResource;
    instance' :=
      ResourceLogic.mkInstance@{
        tag := ResourceLogic.Created (commitment emptyResource);
        commitments := Set.empty;
        nullifiers := Set.empty;
        appData := Set.empty
      };
    witness :=
      ResourceLogic.mkWitness@{
        created := Set.empty;
        consumed := Set.empty;
        custom := Set.empty
      };
    proof := ResourceLogicProof.prove provingKey instance' witness;
  in verifyingKey, proof, witness;

emptyComplianceProof : ComplianceProof.ProofRecord :=
  let
    verifyingKey := Compliance.mkVerifyingKey unit;
    provingKey := Compliance.mkProvingKey unit;
    instance' := Compliance.mkInstance unit;
    witness := Compliance.mkWitness unit;
    proof := ComplianceProof.prove provingKey instance' witness;
  in verifyingKey, proof, witness;

--- A function computing a ;Nullifier; from a ;Resource; and ;ResourceLogic.CustomInputs;.
--- This expects ;NullifierKey; to be present in the ;ResourceLogic.CustomInputs; with the encoded ;Resource; plaintext as the lookup key.
--- If the entry is not present, the ;Universal.nullifierKey; is used instead.
nullifierFromCustomInputs (customInputs : ResourceLogic.CustomInputs) : Resource -> Nullifier :=
  \ {resource :=
    nullifier@{
      resource;
      nullifierKey :=
        fromMaybe
          (Universal.nullifierKey)
          lookupCustomInputs@{
            key := resource;
            customInputs
          }
    }};

--- This expects ;NullifierKey; to be present in the ;ResourceLogic.CustomInputs; with the encoded ;Resource; plaintext as the lookup key.
--- If the resource is not present, ;Universal.nullifierKey; is used instead.
mkActionHelper
  (nullifierKey : NullifierKey)
  (consumed : List Resource)
  (created : List Resource)
  (appData : AppData)
  : Action :=
  mkAction@{
    commitments := Set.fromList (map commitment created);
    nullifiers := Set.fromList (map (nullifier nullifierKey) consumed);
    {-
            commitments := Set.fromList (map \ {r := commitment (CreatedResource.resource r)} (created));
            nullifiers :=
              Set.fromList
                (map
                  \ {rnk := nullifier (ConsumedResource.nullifierKey rnk) (ConsumedResource.resource rnk)}
                  (consumed));
            -}
    proofs := Set.empty;
    appData
  };

mkTransactionHelper (roots : Set CommitmentTree.Root) (actions : Set Action) : Transaction :=
  mkTransaction@{
    roots;
    actions;
    delta := Delta.zero;
    deltaProof := emptyDeltaProof
  };

emptyTx : Transaction :=
  mkTransactionHelper@{
    roots := Set.empty;
    actions := Set.empty
  };

composeAll (txs : List Transaction) : Transaction :=
  for (acc := emptyTx) (tx in txs) {composeTransactions acc tx};

rand : Nat := 0;
