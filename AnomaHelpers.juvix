module AnomaHelpers;

import Stdlib.Prelude open;
import Data.Map open;
import Data.Set open;
import Anoma open;


-- TODO all these helpers should be in `juvix-anoma-stdlib`

syntax alias Bytes32 := Nat;
syntax alias Bytes := Nat;

isCreated (r : Resource) (tx : Transaction) : Bool :=
  elem (==) r (ResourcePartition.created (partitionResources tx));

isConsumed (r : Resource) (tx : Transaction) : Bool :=
  elem (==) r (ResourcePartition.consumed (partitionResources tx));


isPresent (cms : List Helper.Commitment) (cm : Helper.Commitment) : Bool :=
  elem (==) cm cms;

isSublist (sub sup : List Helper.Commitment) : Bool :=
  all (isPresent sup) sub;

isSubset {A} {{Ord A}} (sub sup : Set A) : Bool :=
  all (x in Data.Set.toList sub)
    member? x sup;


isSubsetOfCreatedResources (sub : Set Helper.Commitment) (tx : Transaction) : Bool :=
  let
    sup : Set Helper.Commitment := Data.Set.fromList (map commitment (ResourcePartition.created (partitionResources tx)));
  in
    isSubset sub sup;

lookupExtraData {Value : Type} (key : Bytes32) (tx : Transaction) : Maybe Value :=
  let
    keyValueMap : Map Bytes32 Value := anomaDecode (Transaction.extra tx);
  in
    lookup key keyValueMap;


-- This helper replicates the private key to compute the nullifiers. TODO
mkTransaction
  (self : PrivateKey)
  (consumed : List Resource)
  (created : List Resource)
  (extraData : Map Bytes32 Bytes)
  : Transaction :=
    let
      replicatedPrivKey : List PrivateKey := replicate (length consumed) self;
    in
      Transaction.mk@{
        roots := [];
        commitments := map commitment created;
        nullifiers := zipWith nullifier consumed replicatedPrivKey;
        proofs := consumed ++ created;
        delta := [];
        extra := anomaEncode (extraData);
        preference := 0
      };
