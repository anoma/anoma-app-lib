module AnomaHelpers;

import Stdlib.Prelude open;
import Anoma open;

import Data.Set open;
import Data.Map open;

-- Should be added to the `juvix-stdlib`
type Either Error Result :=
  | left Error
  | right Result;

--- Returns the leftmost element of the list satisfying the predicate or
--- nothing if there's no such element.
find {A} (predicate : A → Bool) : List A → Maybe A
  | nil := nothing
  | (x :: xs) :=
    if
      | predicate x := just x
      | else := find predicate xs;

-- Should be added to the `juvix-anoma-stdlib`
type Bytes32 := mkBytes32 {unBytes32 : Nat};

instance
Bytes32Ord : Ord Bytes32 :=
  mkOrd@{
    cmp : Bytes32 -> Bytes32 -> Ordering
      | (mkBytes32 b1) (mkBytes32 b2) := Ord.cmp b1 b2
  };

natToBytes32 : Nat -> Bytes32 := mkBytes32;

type Bytes := mkBytes {unBytes : Nat};

instance
BytesOrd : Ord Bytes :=
  mkOrd@{
    cmp : Bytes -> Bytes -> Ordering
      | (mkBytes b1) (mkBytes b2) := Ord.cmp b1 b2
  };

natToBytes : Nat -> Bytes := mkBytes;

getLogic (r : Resource) : Nat :=
  anomaEncode (Resource.logic r);

type Error := mkError {msg : String};

type InsufficientElementsError :=
  mkInsufficientElementsError {
    limit : Nat;
    actual : Nat
  };

instance
InsufficientElementsError-Show
  : Show InsufficientElementsError :=
  mkShow
    \ {e :=
      "InsufficientElementsError:\n{"
        ++str "limit : "
        ++str (e |> InsufficientElementsError.limit |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> InsufficientElementsError.actual |> Show.show)
        ++str "}"};

type InsufficientQuantityError :=
  mkInsufficientQuantityError {
    limit : Nat;
    actual : Nat
  };

instance
InsufficientQuantityError-Show
  : Show InsufficientQuantityError :=
  mkShow
    \ {e :=
      "InsufficientQuantityError:\n{"
        ++str "limit : "
        ++str (e |> InsufficientQuantityError.limit |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> InsufficientQuantityError.actual |> Show.show)
        ++str "}"};

type InvalidLogicError :=
  mkInvalidLogicError {
    expected : Nat;
    actual : Nat
  };

instance
InvalidLogicError-Show : Show InvalidLogicError :=
  mkShow
    \ {e :=
      "InvalidLogicError:\n{"
        ++str "expected : "
        ++str (e |> InvalidLogicError.expected |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> InvalidLogicError.actual |> Show.show)
        ++str "}"};

isCreated (r : Resource) (tx : Transaction) : Bool :=
  elem
    (==)
    r
    (ResourcePartition.created (partitionResources tx));

isConsumed (r : Resource) (tx : Transaction) : Bool :=
  elem
    (==)
    r
    (ResourcePartition.consumed (partitionResources tx));

isEphemeral (r : Resource) : Bool := Resource.eph r;

isNullifierPresent
  (nf : Helper.Nullifier) (tx : Transaction) : Bool :=
  elem (==) nf (Transaction.nullifiers tx);

isSubset {A} {{Ord A}} (sub sup : Set A) : Bool :=
  all (x in Data.Set.toList sub)
    member? x sup;

isSublist {A} {{Ord A}} (sub sup : List A) : Bool :=
  all (x in sub)
    member? x (Data.Set.fromList sup);

commitmentSet (tx : Transaction) : Set Helper.Commitment :=
  Data.Set.fromList (Transaction.commitments tx);

nullifierSet (tx : Transaction) : Set Helper.Nullifier :=
  Data.Set.fromList (Transaction.nullifiers tx);

lookupExtraData
  {Value : Type}
  (key : Bytes32)
  (tx : Transaction)
  : Maybe Value :=
  let
    keyValueMap : Map Bytes32 Value :=
      anomaDecode (Transaction.extra tx);
  in lookup key keyValueMap;

mkTransaction
  (self : PrivateKey)
  (consumed : List Resource)
  (created : List Resource)
  (extraData : Map Bytes32 Bytes)
  : Transaction :=
  Transaction.mk@{
    roots := [];
    commitments := map commitment created;
    nullifiers := map (r in consumed) nullifier r self;
    proofs := consumed ++ created;
    delta := [];
    extra := anomaEncode (extraData);
    preference := 0
  };
