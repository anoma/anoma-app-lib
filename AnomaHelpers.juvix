module AnomaHelpers;

import Stdlib.Prelude open;
import Stdlib.Trait.Ord.Eq open using {fromOrdToEq};

import Anoma open;
import Anoma.Rep open;

import Data.Set as Set open using {Set};
import Data.Map as Map open using {Map};

-- Should be added to the `juvix-containers`

union {A} {{Ord A}} (a b : Set A) : Set A := Set.fromList (Set.toList a ++ Set.toList b);

intersection {A} {{Ord A}} (s1 : Set A) (s2 : Set A) : Set A :=
  Set.toList s1 |> filter \ {x := Set.member? x s2} |> Set.fromList;

difference {A} {{Ord A}} (s1 : Set A) (s2 : Set A) : Set A :=
  Set.toList s1 |> filter \ {x := not (Set.member? x s2)} |> Set.fromList;

delete {A B} {{Ord A}} (k : A) : Map A B -> Map A B
  | m@(Map.mkMap s) :=
    case Set.lookupWith Map.key k s of
      | nothing := m
      | just x := Set.delete x s |> Map.mkMap;

-- Should be added to the `juvix-anoma-stdlib`

module Resource;

  npk : Resource -> PublicKey := Resource.npkContents >> fromAtom;

end;

instance
PublicKey-Show : Show PublicKey := mkShow \ {k := natToString (toAtom k)};

instance
PrivateKey-Show : Show PrivateKey := mkShow \ {k := natToString (toAtom k)};

type Bytes32 := mkBytes32 {unBytes32 : Nat};

instance
Bytes32-Ord : Ord Bytes32 :=
  mkOrd@{
    cmp : Bytes32 -> Bytes32 -> Ordering
      | (mkBytes32 b1) (mkBytes32 b2) := Ord.cmp b1 b2
  };

instance
Bytes32-Eq : Eq Bytes32 := Stdlib.Trait.Ord.Eq.fromOrdToEq;

instance
Bytes32-Show : Show Bytes32 := mkShow \ {b := natToString (Bytes32.unBytes32 b)};

natToBytes32 : Nat -> Bytes32 := mkBytes32;

type Bytes := mkBytes {unBytes : Nat};

instance
Bytes-Ord : Ord Bytes :=
  mkOrd@{
    cmp : Bytes -> Bytes -> Ordering
      | (mkBytes b1) (mkBytes b2) := Ord.cmp b1 b2
  };

natToBytes : Nat -> Bytes := mkBytes;

getLogic (r : Resource) : Nat := anomaEncode (Resource.logic r);

type Error := mkError {msg : String};

type InsufficientElementsError :=
  mkInsufficientElementsError {
    limit : Nat;
    actual : Nat
  };

instance
InsufficientElementsError-Show : Show InsufficientElementsError :=
  mkShow
    \ {e :=
      "InsufficientElementsError:\n{"
        ++str "limit : "
        ++str (e |> InsufficientElementsError.limit |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> InsufficientElementsError.actual |> Show.show)
        ++str "}"};

type InsufficientQuantityError :=
  mkInsufficientQuantityError {
    limit : Nat;
    actual : Nat
  };

instance
InsufficientQuantityError-Show : Show InsufficientQuantityError :=
  mkShow
    \ {e :=
      "InsufficientQuantityError:\n{"
        ++str "limit : "
        ++str (e |> InsufficientQuantityError.limit |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> InsufficientQuantityError.actual |> Show.show)
        ++str "}"};

type InvalidLogicError :=
  mkInvalidLogicError {
    expected : Nat;
    actual : Nat
  };

instance
InvalidLogicError-Show : Show InvalidLogicError :=
  mkShow
    \ {e :=
      "InvalidLogicError:\n{"
        ++str "expected : "
        ++str (e |> InvalidLogicError.expected |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> InvalidLogicError.actual |> Show.show)
        ++str "}"};

instance
Kind-Show : Show Kind := mkShow \ {k := natToString (Kind.unKind k)};

type InvalidKindError :=
  mkInvalidKindError {
    expected : Kind;
    actual : Kind
  };

instance
InvalidKindError-Show : Show InvalidKindError :=
  mkShow
    \ {e :=
      "InvalidLogicError:\n{"
        ++str "expected : "
        ++str (e |> InvalidKindError.expected |> Show.show)
        ++str ", "
        ++str "actual"
        ++str (e |> InvalidKindError.actual |> Show.show)
        ++str "}"};

isCreated (r : Resource) (tx : Transaction) : Bool :=
  elem (==) r (ResourcePartition.created (partitionResources tx));

isConsumed (r : Resource) (tx : Transaction) : Bool :=
  elem (==) r (ResourcePartition.consumed (partitionResources tx));

type Lifecycle :=
  | Consumed
  | Created
  | Unknown;

lifecycle (r : Resource) (tx : Transaction) : Lifecycle :=
  let
    rs := partitionResources tx;
    consumed := ResourcePartition.consumed rs;
    created := ResourcePartition.created rs;
  in if
    | elem (==) r consumed := Consumed
    | elem (==) r created := Created
    | else := Unknown;

isEphemeral (r : Resource) : Bool := Resource.eph r;

type Ephemerality :=
  | NonEphemeral
  | Ephemeral;

ephemerality (r : Resource) : Ephemerality :=
  if
    | isEphemeral r := Ephemeral
    | else := NonEphemeral;

isNullifierPresent (nf : Nullifier) (tx : Transaction) : Bool :=
  elem (==) nf (Transaction.nullifiers tx);

isSubset {A} {{Ord A}} (sub sup : Set A) : Bool := all (x in Set.toList sub) Set.member? x sup;

isSublist {A} {{Ord A}} (sub sup : List A) : Bool :=
  all (x in sub)
    Set.member? x (Set.fromList sup);

module Kind;
  toPair (kind : Kind) : Pair (Resource -> Transaction -> Bool) Nat :=
    anomaDecode (Kind.unKind kind);

  toLogic (kind : Kind) : Resource -> Transaction -> Bool := fst (toPair kind);

  toLabel (kind : Kind) : Nat := snd (toPair kind);

  open Kind public;
end;

commitmentSet (tx : Transaction) : Set Commitment := Set.fromList (Transaction.commitments tx);

nullifierSet (tx : Transaction) : Set Nullifier := Set.fromList (Transaction.nullifiers tx);

lookupExtraData {Key Value : Type} (key : Key) (tx : Transaction) : Maybe Value :=
  let
    keyValueMap : Map Bytes32 Bytes := anomaDecode (Transaction.extra tx);
  in map (Bytes.unBytes >> anomaDecode) (Map.lookup (anomaEncode key |> natToBytes32) keyValueMap);

mkTransaction
  (nullifierKey : PrivateKey)
  (consumed : List Resource)
  (created : List Resource)
  (extraData : Map Bytes32 Bytes)
  : Transaction :=
  Transaction.mk@{
    roots := [];
    commitments := map commitment created;
    nullifiers := map (r in consumed) nullifier r nullifierKey;
    proofs := consumed ++ created;
    delta := [];
    extra := anomaEncode (extraData);
    preference := 0
  };

emptyTx : Transaction :=
  Transaction.mk@{
    roots := [];
    commitments := [];
    nullifiers := [];
    proofs := [];
    delta := [];
    extra := 0;
    preference := 0
  };

compose (tx1 tx2 : Transaction) : Transaction :=
  Transaction.mk@{
    roots := Transaction.roots tx1 ++ Transaction.roots tx2;
    commitments := Transaction.commitments tx1 ++ Transaction.commitments tx2;
    nullifiers := Transaction.nullifiers tx1 ++ Transaction.nullifiers tx2;
    proofs := Transaction.proofs tx1 ++ Transaction.proofs tx2;
    delta := Transaction.delta tx1 ++ Transaction.delta tx2;
    extra :=
      let
        kvList1 : List (Pair Bytes32 Bytes) := Map.toList (anomaDecode (Transaction.extra tx1));
        kvList2 : List (Pair Bytes32 Bytes) := Map.toList (anomaDecode (Transaction.extra tx2));
      in anomaEncode (Map.fromList (kvList1 ++ kvList2));
    preference := 0
  };

composeAll (txs : List Transaction) : Transaction :=
  for (acc := emptyTx) (tx in txs) {compose acc tx};

rand : Nat := 0;
